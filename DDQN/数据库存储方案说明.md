# 📊 调度结果数据库存储方案说明

## 🎯 统一数据格式

### 标准数据格式（10个字段）

```json
{
  "id": 1,
  "name": "1-搭架子",
  "workpoint_id": "workpoint_1",
  "workpoint_name": "设备1",
  "team": "team1",
  "start": 0.0,
  "end": 10.5,
  "duration": 10.5,
  "workers": 5,
  "order": 1
}
```

**字段说明**：

| 字段 | 类型 | 说明 | 来源 |
|------|------|------|------|
| `id` | int | 任务唯一标识 | 算法输出 |
| `name` | string | 任务名称 | 算法输出 (`display_name`) |
| `workpoint_id` | string | 设备ID | 算法输出 |
| `workpoint_name` | string | 设备名称 | 算法输出 |
| `team` | string | 团队ID | 算法输出 |
| `start` | float | 开始时间 | 算法输出 |
| `end` | float | 结束时间 | 算法输出 |
| `duration` | float | 持续时间 | 计算得出 (`end - start`) |
| `workers` | int | 分配工人数 | 算法输出 |
| `order` | int | 工序顺序 | 算法输出 |

---

## 📦 数据库表结构

### 新表结构：`schedule_result_{timestamp}`

```sql
CREATE TABLE `schedule_result_20241027_153045` (
    `task_id` INT PRIMARY KEY COMMENT '任务ID',
    `task_name` VARCHAR(100) NOT NULL COMMENT '任务名称',
    `workpoint_id` VARCHAR(50) NOT NULL COMMENT '设备ID',
    `workpoint_name` VARCHAR(50) NOT NULL COMMENT '设备名称',
    `team` VARCHAR(50) NOT NULL COMMENT '团队ID',
    `start_time` DECIMAL(10,2) NOT NULL COMMENT '开始时间',
    `end_time` DECIMAL(10,2) NOT NULL COMMENT '结束时间',
    `duration` DECIMAL(10,2) NOT NULL COMMENT '持续时间',
    `workers` INT NOT NULL COMMENT '分配工人数',
    `process_order` INT COMMENT '工序顺序',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX `idx_workpoint` (`workpoint_id`),
    INDEX `idx_team` (`team`),
    INDEX `idx_start_time` (`start_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci 
COMMENT='算法:DDQN - 完工时间:75.50';
```

**相比旧表结构的改进**：

| 改进项 | 说明 |
|--------|------|
| ✅ 新增 `workpoint_id` | 支持设备视角分组 |
| ✅ 新增 `workpoint_name` | 设备名称显示 |
| ✅ 保留 `duration` | 持续时间（自动计算） |
| ✅ 新增 `process_order` | 工序顺序 |
| ✅ 新增索引 | 优化查询性能 |
| ✅ 表注释存储元数据 | 记录算法名称和完工时间 |

---

## 🔧 新增API方法

### 1. `save_schedule_result()` - 保存调度结果

**功能**: 保存调度结果到数据库（推荐使用）

**参数**:
```python
schedule_data: list  # 调度结果列表（来自 env.get_schedule()）
makespan: float      # 完工时间（可选）
algorithm_name: str  # 算法名称（可选，如 'DDQN', 'Greedy'）
```

**返回**: 
- `str`: 表名（如成功）
- `None`: 如果失败

**使用示例**:
```python
from db_connector import DatabaseConnector

# 创建数据库连接
db = DatabaseConnector(
    host="localhost",
    user="root",
    password="123456",
    database="scheduling_system"
)

# 保存调度结果
table_name = db.save_schedule_result(
    schedule_data=final_schedule,  # 来自 env.get_schedule()
    makespan=75.5,
    algorithm_name='DDQN'
)

if table_name:
    print(f"✅ 成功保存到表: {table_name}")
else:
    print("❌ 保存失败")

db.close()
```

---

### 2. `load_schedule_result()` - 读取调度结果

**功能**: 从数据库读取调度结果

**参数**:
```python
table_name: str  # 表名，如果为None则读取最新的
```

**返回**:
```python
{
    'schedule_data': [...],     # 调度任务列表
    'makespan': 75.5,           # 完工时间
    'algorithm': 'DDQN',        # 算法名称
    'table_name': 'schedule_result_20241027_153045',
    'task_count': 24            # 任务数量
}
```

**使用示例**:
```python
from db_connector import DatabaseConnector

db = DatabaseConnector()

# 读取最新的调度结果
result = db.load_schedule_result()

if result:
    print(f"✅ 读取成功: {result['task_count']} 个任务")
    print(f"   完工时间: {result['makespan']}")
    print(f"   算法: {result['algorithm']}")
    
    # 使用调度数据
    schedule_data = result['schedule_data']
    for task in schedule_data:
        print(f"任务 {task['id']}: {task['name']}")
else:
    print("❌ 读取失败")

db.close()
```

**读取指定表**:
```python
result = db.load_schedule_result(table_name='schedule_result_20241027_153045')
```

---

### 3. `list_schedule_results()` - 列出所有调度结果

**功能**: 列出数据库中的所有调度结果表

**参数**:
```python
limit: int  # 返回的最大数量，默认10
```

**返回**:
```python
[
    {
        'table_name': 'schedule_result_20241027_153045',
        'comment': '算法:DDQN - 完工时间:75.50',
        'created_at': '2024-10-27 15:30:45',
        'task_count': 24
    },
    {
        'table_name': 'schedule_result_20241027_120030',
        'comment': '算法:Greedy - 完工时间:80.20',
        'created_at': '2024-10-27 12:00:30',
        'task_count': 24
    },
    ...
]
```

**使用示例**:
```python
from db_connector import DatabaseConnector

db = DatabaseConnector()

# 列出最近10个调度结果
results = db.list_schedule_results(limit=10)

if results:
    print(f"📋 找到 {len(results)} 个调度结果:")
    for r in results:
        print(f"  - {r['table_name']}: {r['comment']} ({r['task_count']} 任务)")
else:
    print("ℹ️  没有找到调度结果")

db.close()
```

---

## 🔄 集成到调度算法

### 方案A: 在 `main.py` 中保存

```python
# DDQN/main.py

def RUN(workpoints_data, save_processes_to_db=True):
    """多工作点调度算法主函数"""
    
    # ... 运行算法 ...
    
    # 获取最优结果
    final_schedule = current_best['schedule']
    final_makespan = current_best['makespan']
    best_algorithm = current_best['algorithm']
    
    # 保存到数据库
    if save_processes_to_db:
        from db_connector import DatabaseConnector
        db = DatabaseConnector()
        
        table_name = db.save_schedule_result(
            schedule_data=final_schedule,
            makespan=final_makespan,
            algorithm_name=best_algorithm
        )
        
        if table_name:
            print(f"✅ 调度结果已保存到数据库: {table_name}")
        
        db.close()
    
    # 生成可视化
    record, process_fig, workpoint_fig, team_fig = save_gantt_charts(
        final_schedule, final_makespan, env
    )
    
    return final_schedule, final_makespan, process_fig, workpoint_fig, team_fig
```

---

### 方案B: 在 `Flask.py` 中保存

```python
# DDQN/Flask.py

@app.route('/run_ddqn', methods=['POST'])
def run_algorithm():
    """运行DDQN调度算法"""
    try:
        # 运行算法
        result = RUN(workpoints_data, save_processes_to_db=False)
        
        if result is None:
            return jsonify({"error": "算法运行失败"}), 500
        
        schedule, makespan, process_fig, workpoint_fig, team_fig = result
        
        # 保存到数据库
        from db_connector import DatabaseConnector
        db = DatabaseConnector()
        
        table_name = db.save_schedule_result(
            schedule_data=schedule,
            makespan=makespan,
            algorithm_name='DDQN'
        )
        
        db.close()
        
        # 转换图片为base64
        images = {
            'process_gantt': fig_to_base64(process_fig),
            'workpoint_gantt': fig_to_base64(workpoint_fig),
            'team_gantt': fig_to_base64(team_fig)
        }
        
        return jsonify({
            "schedule_data": schedule,  # 调度数据
            "makespan": float(makespan),
            "table_name": table_name,   # 数据库表名
            "gantt_charts": images,
            "chart_info": {...}
        })
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500
```

---

## 📊 数据流程图

```
调度算法运行 (scheduling_environment.py)
    ↓
生成 schedule 列表 (env.get_schedule())
    ↓ {id, name, workpoint_id, workpoint_name, team, start, end, workers, order}
    ↓
┌───────────────────┴────────────────────┐
│                                        │
↓                                        ↓
保存到数据库                        返回给Flask API
(db.save_schedule_result)              (Flask.py)
    ↓                                    ↓
schedule_result_{timestamp}          JSON 返回
    ↓                                    ↓
可查询历史结果                      前端渲染
(db.load_schedule_result)          (DHTMLX Gantt)
```

---

## 🧪 测试用例

### 测试1: 保存和读取调度结果

```python
# test_db_storage.py

from db_connector import DatabaseConnector

# 模拟调度结果数据
test_schedule = [
    {
        'id': 1,
        'name': '1-搭架子',
        'workpoint_id': 'workpoint_1',
        'workpoint_name': '设备1',
        'team': 'team1',
        'start': 0.0,
        'end': 10.5,
        'workers': 5,
        'order': 1
    },
    {
        'id': 2,
        'name': '1-拆保温',
        'workpoint_id': 'workpoint_1',
        'workpoint_name': '设备1',
        'team': 'team2',
        'start': 10.5,
        'end': 15.3,
        'workers': 8,
        'order': 2
    }
]

# 创建数据库连接
db = DatabaseConnector(database="scheduling_system")

# 测试保存
print("测试保存调度结果...")
table_name = db.save_schedule_result(
    schedule_data=test_schedule,
    makespan=15.3,
    algorithm_name='TEST'
)

if table_name:
    print(f"✅ 保存成功: {table_name}")
    
    # 测试读取
    print("\n测试读取调度结果...")
    result = db.load_schedule_result(table_name=table_name)
    
    if result:
        print(f"✅ 读取成功:")
        print(f"   任务数: {result['task_count']}")
        print(f"   完工时间: {result['makespan']}")
        print(f"   算法: {result['algorithm']}")
        print(f"   数据完整性: {len(result['schedule_data']) == len(test_schedule)}")
    else:
        print("❌ 读取失败")
else:
    print("❌ 保存失败")

db.close()
```

---

### 测试2: 列出历史结果

```python
from db_connector import DatabaseConnector

db = DatabaseConnector(database="scheduling_system")

# 列出所有调度结果
results = db.list_schedule_results(limit=5)

if results:
    print(f"📋 最近 {len(results)} 个调度结果:\n")
    for i, r in enumerate(results, 1):
        print(f"{i}. {r['table_name']}")
        print(f"   描述: {r['comment']}")
        print(f"   任务数: {r['task_count']}")
        print(f"   创建时间: {r['created_at']}\n")
else:
    print("ℹ️  没有找到调度结果")

db.close()
```

---

## 📝 注意事项

### 1. 数据库配置

确保数据库配置正确：

```python
db = DatabaseConnector(
    host="localhost",         # 数据库主机
    user="root",              # 用户名
    password="123456",        # 密码
    database="scheduling_system"  # 数据库名（需提前创建）
)
```

### 2. 数据库创建

首次使用前需要创建数据库：

```sql
CREATE DATABASE IF NOT EXISTS scheduling_system 
DEFAULT CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;
```

### 3. 权限设置

确保MySQL用户有创建表的权限：

```sql
GRANT CREATE, INSERT, SELECT, DROP ON scheduling_system.* TO 'root'@'localhost';
FLUSH PRIVILEGES;
```

### 4. 旧方法兼容性

旧的 `save_task_schedule()` 方法仍然保留，但已标记为废弃。建议使用新的 `save_schedule_result()` 方法。

### 5. 持续时间自动计算

`duration` 字段在保存时自动计算（`end - start`），无需手动传入。

---

## 🎯 优势总结

| 特性 | 说明 |
|------|------|
| ✅ 数据格式统一 | 算法输出 = 数据库存储 = API返回 = 前端需求 |
| ✅ 支持三种视角 | workpoint_id + team + order 全部包含 |
| ✅ 历史记录查询 | 可查询和对比不同时间的调度结果 |
| ✅ 元数据存储 | 表注释记录算法名称和完工时间 |
| ✅ 性能优化 | 添加索引，优化查询速度 |
| ✅ 向后兼容 | 保留旧方法，不影响现有功能 |
| ✅ 持续时间字段 | 保留 duration 字段，方便查询和统计 |

---

## 📞 后续扩展

### 可能的功能扩展：

1. **结果对比功能**
   - 对比不同算法的调度结果
   - 对比不同参数的优化效果

2. **统计分析**
   - 完工时间趋势分析
   - 设备利用率统计
   - 团队工作负载分析

3. **结果筛选**
   - 按算法筛选
   - 按完工时间范围筛选
   - 按日期筛选

4. **数据导出**
   - 导出为Excel
   - 导出为CSV
   - 导出为JSON

---

**数据库存储方案已完成！** ✅

