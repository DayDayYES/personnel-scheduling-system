{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, each, find, isString, map, trim } from 'zrender/lib/core/util.js';\nimport { error } from '../util/log.js';\nimport { registerScaleBreakHelperImpl } from './break.js';\nimport { round as fixRound } from '../util/number.js';\n/**\n * @caution\n *  Must not export anything except `installScaleBreakHelper`\n */\nvar ScaleBreakContextImpl = /** @class */function () {\n  function ScaleBreakContextImpl() {\n    // [CAVEAT]: Should set only by `ScaleBreakContext#setBreaks`!\n    this.breaks = [];\n    // [CAVEAT]: Should update only by `ScaleBreakContext#update`!\n    // They are the values that scaleExtent[0] and scaleExtent[1] are mapped to a numeric axis\n    // that breaks are applied, primarily for optimization of `Scale#normalize`.\n    this._elapsedExtent = [Infinity, -Infinity];\n  }\n  ScaleBreakContextImpl.prototype.setBreaks = function (parsed) {\n    // @ts-ignore\n    this.breaks = parsed.breaks;\n  };\n  /**\n   * [CAVEAT]: Must be called immediately each time scale extent and breaks are updated!\n   */\n  ScaleBreakContextImpl.prototype.update = function (scaleExtent) {\n    updateAxisBreakGapReal(this, scaleExtent);\n    var elapsedExtent = this._elapsedExtent;\n    elapsedExtent[0] = this.elapse(scaleExtent[0]);\n    elapsedExtent[1] = this.elapse(scaleExtent[1]);\n  };\n  ScaleBreakContextImpl.prototype.hasBreaks = function () {\n    return !!this.breaks.length;\n  };\n  /**\n   * When iteratively generating ticks by nice interval, currently the `interval`, which is\n   * calculated by break-elapsed extent span, is probably very small comparing to the original\n   * extent, leading to a large number of iteration and tick generation, even over `safeLimit`.\n   * Thus stepping over breaks is necessary in that loop.\n   *\n   * \"Nice\" should be ensured on ticks when step over the breaks. Thus this method returns\n   * a integer multiple of the \"nice tick interval\".\n   *\n   * This method does little work; it is just for unifying and restricting the behavior.\n   */\n  ScaleBreakContextImpl.prototype.calcNiceTickMultiple = function (tickVal, estimateNiceMultiple) {\n    for (var idx = 0; idx < this.breaks.length; idx++) {\n      var brk = this.breaks[idx];\n      if (brk.vmin < tickVal && tickVal < brk.vmax) {\n        var multiple = estimateNiceMultiple(tickVal, brk.vmax);\n        if (process.env.NODE_ENV !== 'production') {\n          // If not, it may cause dead loop or not nice tick.\n          assert(multiple >= 0 && Math.round(multiple) === multiple);\n        }\n        return multiple;\n      }\n    }\n    return 0;\n  };\n  ScaleBreakContextImpl.prototype.getExtentSpan = function () {\n    return this._elapsedExtent[1] - this._elapsedExtent[0];\n  };\n  ScaleBreakContextImpl.prototype.normalize = function (val) {\n    var elapsedSpan = this._elapsedExtent[1] - this._elapsedExtent[0];\n    // The same logic as `Scale#normalize`.\n    if (elapsedSpan === 0) {\n      return 0.5;\n    }\n    return (this.elapse(val) - this._elapsedExtent[0]) / elapsedSpan;\n  };\n  ScaleBreakContextImpl.prototype.scale = function (val) {\n    return this.unelapse(val * (this._elapsedExtent[1] - this._elapsedExtent[0]) + this._elapsedExtent[0]);\n  };\n  /**\n   * Suppose:\n   *    AXIS_BREAK_LAST_BREAK_END_BASE: 0\n   *    AXIS_BREAK_ELAPSED_BASE: 0\n   *    breaks: [\n   *        {start: -400, end: -300, gap: 27},\n   *        {start: -100, end: 100, gap: 10},\n   *        {start: 200, end: 400, gap: 300},\n   *    ]\n   * The mapping will be:\n   *        |        |\n   *    400 +   ->   +  237\n   *     |  |        |   |  (gap: 300)\n   *    200 +   ->   + -63\n   *        |        |\n   *    100 +   ->   + -163\n   *     |  |        |   |  (gap: 10)\n   *   -100 +   ->   + -173\n   *        |        |\n   *   -300 +   ->   + -373\n   *     |  |        |   |  (gap: 27)\n   *   -400 +   ->   + -400\n   *        |        |\n   *   origianl     elapsed\n   *\n   * Note:\n   *   The mapping has nothing to do with \"scale extent\".\n   */\n  ScaleBreakContextImpl.prototype.elapse = function (val) {\n    // If the value is in the break, return the normalized value in the break\n    var elapsedVal = AXIS_BREAK_ELAPSED_BASE;\n    var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;\n    var stillOver = true;\n    for (var i = 0; i < this.breaks.length; i++) {\n      var brk = this.breaks[i];\n      if (val <= brk.vmax) {\n        if (val > brk.vmin) {\n          elapsedVal += brk.vmin - lastBreakEnd + (val - brk.vmin) / (brk.vmax - brk.vmin) * brk.gapReal;\n        } else {\n          elapsedVal += val - lastBreakEnd;\n        }\n        lastBreakEnd = brk.vmax;\n        stillOver = false;\n        break;\n      }\n      elapsedVal += brk.vmin - lastBreakEnd + brk.gapReal;\n      lastBreakEnd = brk.vmax;\n    }\n    if (stillOver) {\n      elapsedVal += val - lastBreakEnd;\n    }\n    return elapsedVal;\n  };\n  ScaleBreakContextImpl.prototype.unelapse = function (elapsedVal) {\n    var lastElapsedEnd = AXIS_BREAK_ELAPSED_BASE;\n    var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;\n    var stillOver = true;\n    var unelapsedVal = 0;\n    for (var i = 0; i < this.breaks.length; i++) {\n      var brk = this.breaks[i];\n      var elapsedStart = lastElapsedEnd + brk.vmin - lastBreakEnd;\n      var elapsedEnd = elapsedStart + brk.gapReal;\n      if (elapsedVal <= elapsedEnd) {\n        if (elapsedVal > elapsedStart) {\n          unelapsedVal = brk.vmin + (elapsedVal - elapsedStart) / (elapsedEnd - elapsedStart) * (brk.vmax - brk.vmin);\n        } else {\n          unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;\n        }\n        lastBreakEnd = brk.vmax;\n        stillOver = false;\n        break;\n      }\n      lastElapsedEnd = elapsedEnd;\n      lastBreakEnd = brk.vmax;\n    }\n    if (stillOver) {\n      unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;\n    }\n    return unelapsedVal;\n  };\n  return ScaleBreakContextImpl;\n}();\n;\nfunction createScaleBreakContext() {\n  return new ScaleBreakContextImpl();\n}\n// Both can start with any finite value, and are not necessaryily equal. But they need to\n// be the same in `axisBreakElapse` and `axisBreakUnelapse` respectively.\nvar AXIS_BREAK_ELAPSED_BASE = 0;\nvar AXIS_BREAK_LAST_BREAK_END_BASE = 0;\n/**\n * `gapReal` in brkCtx.breaks will be calculated.\n */\nfunction updateAxisBreakGapReal(brkCtx, scaleExtent) {\n  // Considered the effect:\n  //  - Use dataZoom to move some of the breaks outside the extent.\n  //  - Some scenarios that `series.clip: false`.\n  //\n  // How to calculate `prctBrksGapRealSum`:\n  //  Based on the formula:\n  //      xxx.span = brk.vmax - brk.vmin\n  //      xxx.tpPrct.val / xxx.tpAbs.val means ParsedAxisBreak['gapParsed']['val']\n  //      .S/.E means a break that is semi in scaleExtent[0] or scaleExtent[1]\n  //      valP = (\n  //          + (fullyInExtBrksSum.tpAbs.gapReal - fullyInExtBrksSum.tpAbs.span)\n  //          + (semiInExtBrk.S.tpAbs.gapReal - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac\n  //          + (semiInExtBrk.E.tpAbs.gapReal - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac\n  //      )\n  //      valQ = (\n  //          - fullyInExtBrksSum.tpPrct.span\n  //          - semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac\n  //          - semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac\n  //      )\n  //      gapPrctSum = sum(xxx.tpPrct.val)\n  //      gapPrctSum = prctBrksGapRealSum / (\n  //          + (scaleExtent[1] - scaleExtent[0]) + valP + valQ\n  //          + fullyInExtBrksSum.tpPrct.gapReal\n  //          + semiInExtBrk.S.tpPrct.gapReal * semiInExtBrk.S.tpPrct.inExtFrac\n  //          + semiInExtBrk.E.tpPrct.gapReal * semiInExtBrk.E.tpPrct.inExtFrac\n  //      )\n  //  Assume:\n  //      xxx.tpPrct.gapReal = xxx.tpPrct.val / gapPrctSum * prctBrksGapRealSum\n  //         (NOTE: This is not accurate when semi-in-extent break exist because its\n  //         proportion is not linear, but this assumption approximately works.)\n  //  Derived as follows:\n  //      prctBrksGapRealSum = gapPrctSum * ( (scaleExtent[1] - scaleExtent[0]) + valP + valQ )\n  //          / (1\n  //              - fullyInExtBrksSum.tpPrct.val\n  //              - semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac\n  //              - semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac\n  //          )\n  var gapPrctSum = 0;\n  var fullyInExtBrksSum = {\n    tpAbs: {\n      span: 0,\n      val: 0\n    },\n    tpPrct: {\n      span: 0,\n      val: 0\n    }\n  };\n  var init = function () {\n    return {\n      has: false,\n      span: NaN,\n      inExtFrac: NaN,\n      val: NaN\n    };\n  };\n  var semiInExtBrk = {\n    S: {\n      tpAbs: init(),\n      tpPrct: init()\n    },\n    E: {\n      tpAbs: init(),\n      tpPrct: init()\n    }\n  };\n  each(brkCtx.breaks, function (brk) {\n    var gapParsed = brk.gapParsed;\n    if (gapParsed.type === 'tpPrct') {\n      gapPrctSum += gapParsed.val;\n    }\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (clampedBrk) {\n      var vminClamped = clampedBrk.vmin !== brk.vmin;\n      var vmaxClamped = clampedBrk.vmax !== brk.vmax;\n      var clampedSpan = clampedBrk.vmax - clampedBrk.vmin;\n      if (vminClamped && vmaxClamped) {\n        // Do nothing, which simply makes the result `gapReal` cover the entire scaleExtent.\n        // This transform is not consistent with the other cases but practically works.\n      } else if (vminClamped || vmaxClamped) {\n        var sOrE = vminClamped ? 'S' : 'E';\n        semiInExtBrk[sOrE][gapParsed.type].has = true;\n        semiInExtBrk[sOrE][gapParsed.type].span = clampedSpan;\n        semiInExtBrk[sOrE][gapParsed.type].inExtFrac = clampedSpan / (brk.vmax - brk.vmin);\n        semiInExtBrk[sOrE][gapParsed.type].val = gapParsed.val;\n      } else {\n        fullyInExtBrksSum[gapParsed.type].span += clampedSpan;\n        fullyInExtBrksSum[gapParsed.type].val += gapParsed.val;\n      }\n    }\n  });\n  var prctBrksGapRealSum = gapPrctSum * (0 + (scaleExtent[1] - scaleExtent[0]) + (fullyInExtBrksSum.tpAbs.val - fullyInExtBrksSum.tpAbs.span) + (semiInExtBrk.S.tpAbs.has ? (semiInExtBrk.S.tpAbs.val - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac : 0) + (semiInExtBrk.E.tpAbs.has ? (semiInExtBrk.E.tpAbs.val - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac : 0) - fullyInExtBrksSum.tpPrct.span - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac : 0)) / (1 - fullyInExtBrksSum.tpPrct.val - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac : 0));\n  each(brkCtx.breaks, function (brk) {\n    var gapParsed = brk.gapParsed;\n    if (gapParsed.type === 'tpPrct') {\n      brk.gapReal = gapPrctSum !== 0\n      // prctBrksGapRealSum is supposed to be non-negative but add a safe guard\n      ? Math.max(prctBrksGapRealSum, 0) * gapParsed.val / gapPrctSum : 0;\n    }\n    if (gapParsed.type === 'tpAbs') {\n      brk.gapReal = gapParsed.val;\n    }\n    if (brk.gapReal == null) {\n      brk.gapReal = 0;\n    }\n  });\n}\nfunction pruneTicksByBreak(pruneByBreak, ticks, breaks, getValue, interval, scaleExtent) {\n  if (pruneByBreak === 'no') {\n    return;\n  }\n  each(breaks, function (brk) {\n    // break.vmin/vmax that out of extent must not impact the visible of\n    // normal ticks and labels.\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (!clampedBrk) {\n      return;\n    }\n    // Remove some normal ticks to avoid zigzag shapes overlapping with split lines\n    // and to avoid break labels overlapping with normal tick labels (thouth it can\n    // also be avoided by `axisLabel.hideOverlap`).\n    // It's OK to O(n^2) since the number of `ticks` are small.\n    for (var j = ticks.length - 1; j >= 0; j--) {\n      var tick = ticks[j];\n      var val = getValue(tick);\n      // 1. Ensure there is no ticks inside `break.vmin` and `break.vmax`.\n      // 2. Use an empirically gap value here. Theoritically `zigzagAmplitude` is\n      //  supposed to be involved to provide better precision but it will brings\n      //  more complexity. The empirically gap value is conservative because break\n      //  labels and normal tick lables are prone to overlapping.\n      var gap = interval * 3 / 4;\n      if (val > clampedBrk.vmin - gap && val < clampedBrk.vmax + gap && (pruneByBreak !== 'preserve_extent_bound' || val !== scaleExtent[0] && val !== scaleExtent[1])) {\n        ticks.splice(j, 1);\n      }\n    }\n  });\n}\nfunction addBreaksToTicks(\n// The input ticks should be in accending order.\nticks, breaks, scaleExtent,\n// Keep the break ends at the same level to avoid an awkward appearance.\ngetTimeProps) {\n  each(breaks, function (brk) {\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (!clampedBrk) {\n      return;\n    }\n    // - When neight `break.vmin` nor `break.vmax` is in scale extent,\n    //  break label should not be displayed and we do not add them to the result.\n    // - When only one of `break.vmin` and `break.vmax` is inside the extent and the\n    //  other is outsite, we comply with the extent and display only part of the breaks area,\n    //  because the extent might be determined by user settings (such as `axis.min/max`)\n    ticks.push({\n      value: clampedBrk.vmin,\n      \"break\": {\n        type: 'vmin',\n        parsedBreak: clampedBrk\n      },\n      time: getTimeProps ? getTimeProps(clampedBrk) : undefined\n    });\n    // When gap is 0, start tick overlap with end tick, but we still count both of them. Break\n    // area shape can address that overlapping. `axisLabel` need draw both start and end separately,\n    // otherwise it brings complexity to the logic of label overlapping resolving (e.g., when label\n    // rotated), and introduces inconsistency to users in `axisLabel.formatter` between gap is 0 or not.\n    ticks.push({\n      value: clampedBrk.vmax,\n      \"break\": {\n        type: 'vmax',\n        parsedBreak: clampedBrk\n      },\n      time: getTimeProps ? getTimeProps(clampedBrk) : undefined\n    });\n  });\n  if (breaks.length) {\n    ticks.sort(function (a, b) {\n      return a.value - b.value;\n    });\n  }\n}\n/**\n * If break and extent does not intersect, return null/undefined.\n * If the intersection is only a point at scaleExtent[0] or scaleExtent[1], return null/undefined.\n */\nfunction clampBreakByExtent(brk, scaleExtent) {\n  var vmin = Math.max(brk.vmin, scaleExtent[0]);\n  var vmax = Math.min(brk.vmax, scaleExtent[1]);\n  return vmin < vmax || vmin === vmax && vmin > scaleExtent[0] && vmin < scaleExtent[1] ? {\n    vmin: vmin,\n    vmax: vmax,\n    breakOption: brk.breakOption,\n    gapParsed: brk.gapParsed,\n    gapReal: brk.gapReal\n  } : null;\n}\nfunction parseAxisBreakOption(\n// raw user input breaks, retrieved from axis model.\nbreakOptionList, parse, opt) {\n  var parsedBreaks = [];\n  if (!breakOptionList) {\n    return {\n      breaks: parsedBreaks\n    };\n  }\n  function validatePercent(normalizedPercent, msg) {\n    if (normalizedPercent >= 0 && normalizedPercent < 1 - 1e-5) {\n      // Avoid division error.\n      return true;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      error(msg + \" must be >= 0 and < 1, rather than \" + normalizedPercent + \" .\");\n    }\n    return false;\n  }\n  each(breakOptionList, function (brkOption) {\n    if (!brkOption || brkOption.start == null || brkOption.end == null) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('The input axis breaks start/end should not be empty.');\n      }\n      return;\n    }\n    if (brkOption.isExpanded) {\n      return;\n    }\n    var parsedBrk = {\n      breakOption: clone(brkOption),\n      vmin: parse(brkOption.start),\n      vmax: parse(brkOption.end),\n      gapParsed: {\n        type: 'tpAbs',\n        val: 0\n      },\n      gapReal: null\n    };\n    if (brkOption.gap != null) {\n      var isPrct = false;\n      if (isString(brkOption.gap)) {\n        var trimmedGap = trim(brkOption.gap);\n        if (trimmedGap.match(/%$/)) {\n          var normalizedPercent = parseFloat(trimmedGap) / 100;\n          if (!validatePercent(normalizedPercent, 'Percent gap')) {\n            normalizedPercent = 0;\n          }\n          parsedBrk.gapParsed.type = 'tpPrct';\n          parsedBrk.gapParsed.val = normalizedPercent;\n          isPrct = true;\n        }\n      }\n      if (!isPrct) {\n        var absolute = parse(brkOption.gap);\n        if (!isFinite(absolute) || absolute < 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Axis breaks gap must positive finite rather than (\" + brkOption.gap + \").\");\n          }\n          absolute = 0;\n        }\n        parsedBrk.gapParsed.type = 'tpAbs';\n        parsedBrk.gapParsed.val = absolute;\n      }\n    }\n    if (parsedBrk.vmin === parsedBrk.vmax) {\n      parsedBrk.gapParsed.type = 'tpAbs';\n      parsedBrk.gapParsed.val = 0;\n    }\n    if (opt && opt.noNegative) {\n      each(['vmin', 'vmax'], function (se) {\n        if (parsedBrk[se] < 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Axis break.\" + se + \" must not be negative.\");\n          }\n          parsedBrk[se] = 0;\n        }\n      });\n    }\n    // Ascending numerical order is the prerequisite of the calculation in Scale#normalize.\n    // User are allowed to input desending vmin/vmax for simplifying the usage.\n    if (parsedBrk.vmin > parsedBrk.vmax) {\n      var tmp = parsedBrk.vmax;\n      parsedBrk.vmax = parsedBrk.vmin;\n      parsedBrk.vmin = tmp;\n    }\n    parsedBreaks.push(parsedBrk);\n  });\n  // Ascending numerical order is the prerequisite of the calculation in Scale#normalize.\n  parsedBreaks.sort(function (item1, item2) {\n    return item1.vmin - item2.vmin;\n  });\n  // Make sure that the intervals in breaks are not overlap.\n  var lastEnd = -Infinity;\n  each(parsedBreaks, function (brk, idx) {\n    if (lastEnd > brk.vmin) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('Axis breaks must not overlap.');\n      }\n      parsedBreaks[idx] = null;\n    }\n    lastEnd = brk.vmax;\n  });\n  return {\n    breaks: parsedBreaks.filter(function (brk) {\n      return !!brk;\n    })\n  };\n}\nfunction identifyAxisBreak(brk, identifier) {\n  return serializeAxisBreakIdentifier(identifier) === serializeAxisBreakIdentifier(brk);\n}\nfunction serializeAxisBreakIdentifier(identifier) {\n  // We use user input start/end to identify break. Considered cases like `start: new Date(xxx)`,\n  // Theoretically `Scale#parse` should be used here, but not used currently to reduce dependencies,\n  // since simply converting to string happens to be correct.\n  return identifier.start + '_\\0_' + identifier.end;\n}\n/**\n * - A break pair represents `[vmin, vmax]`,\n * - Only both vmin and vmax item exist, they are counted as a pair.\n */\nfunction retrieveAxisBreakPairs(itemList, getVisualAxisBreak, returnIdx) {\n  var idxPairList = [];\n  each(itemList, function (el, idx) {\n    var vBreak = getVisualAxisBreak(el);\n    if (vBreak && vBreak.type === 'vmin') {\n      idxPairList.push([idx]);\n    }\n  });\n  each(itemList, function (el, idx) {\n    var vBreak = getVisualAxisBreak(el);\n    if (vBreak && vBreak.type === 'vmax') {\n      var idxPair = find(idxPairList,\n      // parsedBreak may be changed, can only use breakOption to match them.\n      function (pr) {\n        return identifyAxisBreak(getVisualAxisBreak(itemList[pr[0]]).parsedBreak.breakOption, vBreak.parsedBreak.breakOption);\n      });\n      idxPair && idxPair.push(idx);\n    }\n  });\n  var result = [];\n  each(idxPairList, function (idxPair) {\n    if (idxPair.length === 2) {\n      result.push(returnIdx ? idxPair : [itemList[idxPair[0]], itemList[idxPair[1]]]);\n    }\n  });\n  return result;\n}\nfunction getTicksLogTransformBreak(tick, logBase, logOriginalBreaks, fixRoundingError) {\n  var vBreak;\n  var brkRoundingCriterion;\n  if (tick[\"break\"]) {\n    var brk = tick[\"break\"].parsedBreak;\n    var originalBreak = find(logOriginalBreaks, function (brk) {\n      return identifyAxisBreak(brk.breakOption, tick[\"break\"].parsedBreak.breakOption);\n    });\n    var vmin = fixRoundingError(Math.pow(logBase, brk.vmin), originalBreak.vmin);\n    var vmax = fixRoundingError(Math.pow(logBase, brk.vmax), originalBreak.vmax);\n    var gapParsed = {\n      type: brk.gapParsed.type,\n      val: brk.gapParsed.type === 'tpAbs' ? fixRound(Math.pow(logBase, brk.vmin + brk.gapParsed.val)) - vmin : brk.gapParsed.val\n    };\n    vBreak = {\n      type: tick[\"break\"].type,\n      parsedBreak: {\n        breakOption: brk.breakOption,\n        vmin: vmin,\n        vmax: vmax,\n        gapParsed: gapParsed,\n        gapReal: brk.gapReal\n      }\n    };\n    brkRoundingCriterion = originalBreak[tick[\"break\"].type];\n  }\n  return {\n    brkRoundingCriterion: brkRoundingCriterion,\n    vBreak: vBreak\n  };\n}\nfunction logarithmicParseBreaksFromOption(breakOptionList, logBase, parse) {\n  var opt = {\n    noNegative: true\n  };\n  var parsedOriginal = parseAxisBreakOption(breakOptionList, parse, opt);\n  var parsedLogged = parseAxisBreakOption(breakOptionList, parse, opt);\n  var loggedBase = Math.log(logBase);\n  parsedLogged.breaks = map(parsedLogged.breaks, function (brk) {\n    var vmin = Math.log(brk.vmin) / loggedBase;\n    var vmax = Math.log(brk.vmax) / loggedBase;\n    var gapParsed = {\n      type: brk.gapParsed.type,\n      val: brk.gapParsed.type === 'tpAbs' ? Math.log(brk.vmin + brk.gapParsed.val) / loggedBase - vmin : brk.gapParsed.val\n    };\n    return {\n      vmin: vmin,\n      vmax: vmax,\n      gapParsed: gapParsed,\n      gapReal: brk.gapReal,\n      breakOption: brk.breakOption\n    };\n  });\n  return {\n    parsedOriginal: parsedOriginal,\n    parsedLogged: parsedLogged\n  };\n}\nvar BREAK_MIN_MAX_TO_PARAM = {\n  vmin: 'start',\n  vmax: 'end'\n};\nfunction makeAxisLabelFormatterParamBreak(extraParam, vBreak) {\n  if (vBreak) {\n    extraParam = extraParam || {};\n    extraParam[\"break\"] = {\n      type: BREAK_MIN_MAX_TO_PARAM[vBreak.type],\n      start: vBreak.parsedBreak.vmin,\n      end: vBreak.parsedBreak.vmax\n    };\n  }\n  return extraParam;\n}\nexport function installScaleBreakHelper() {\n  registerScaleBreakHelperImpl({\n    createScaleBreakContext: createScaleBreakContext,\n    pruneTicksByBreak: pruneTicksByBreak,\n    addBreaksToTicks: addBreaksToTicks,\n    parseAxisBreakOption: parseAxisBreakOption,\n    identifyAxisBreak: identifyAxisBreak,\n    serializeAxisBreakIdentifier: serializeAxisBreakIdentifier,\n    retrieveAxisBreakPairs: retrieveAxisBreakPairs,\n    getTicksLogTransformBreak: getTicksLogTransformBreak,\n    logarithmicParseBreaksFromOption: logarithmicParseBreaksFromOption,\n    makeAxisLabelFormatterParamBreak: makeAxisLabelFormatterParamBreak\n  });\n}","map":{"version":3,"names":["assert","clone","each","find","isString","map","trim","error","registerScaleBreakHelperImpl","round","fixRound","ScaleBreakContextImpl","breaks","_elapsedExtent","Infinity","prototype","setBreaks","parsed","update","scaleExtent","updateAxisBreakGapReal","elapsedExtent","elapse","hasBreaks","length","calcNiceTickMultiple","tickVal","estimateNiceMultiple","idx","brk","vmin","vmax","multiple","process","env","NODE_ENV","Math","getExtentSpan","normalize","val","elapsedSpan","scale","unelapse","elapsedVal","AXIS_BREAK_ELAPSED_BASE","lastBreakEnd","AXIS_BREAK_LAST_BREAK_END_BASE","stillOver","i","gapReal","lastElapsedEnd","unelapsedVal","elapsedStart","elapsedEnd","createScaleBreakContext","brkCtx","gapPrctSum","fullyInExtBrksSum","tpAbs","span","tpPrct","init","has","NaN","inExtFrac","semiInExtBrk","S","E","gapParsed","type","clampedBrk","clampBreakByExtent","vminClamped","vmaxClamped","clampedSpan","sOrE","prctBrksGapRealSum","max","pruneTicksByBreak","pruneByBreak","ticks","getValue","interval","j","tick","gap","splice","addBreaksToTicks","getTimeProps","push","value","parsedBreak","time","undefined","sort","a","b","min","breakOption","parseAxisBreakOption","breakOptionList","parse","opt","parsedBreaks","validatePercent","normalizedPercent","msg","brkOption","start","end","isExpanded","parsedBrk","isPrct","trimmedGap","match","parseFloat","absolute","isFinite","noNegative","se","tmp","item1","item2","lastEnd","filter","identifyAxisBreak","identifier","serializeAxisBreakIdentifier","retrieveAxisBreakPairs","itemList","getVisualAxisBreak","returnIdx","idxPairList","el","vBreak","idxPair","pr","result","getTicksLogTransformBreak","logBase","logOriginalBreaks","fixRoundingError","brkRoundingCriterion","originalBreak","pow","logarithmicParseBreaksFromOption","parsedOriginal","parsedLogged","loggedBase","log","BREAK_MIN_MAX_TO_PARAM","makeAxisLabelFormatterParamBreak","extraParam","installScaleBreakHelper"],"sources":["D:/Program Files/JetBrains/IDEAProject/springboot-vue-wms_test/vuedemo2/node_modules/echarts/lib/scale/breakImpl.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, each, find, isString, map, trim } from 'zrender/lib/core/util.js';\nimport { error } from '../util/log.js';\nimport { registerScaleBreakHelperImpl } from './break.js';\nimport { round as fixRound } from '../util/number.js';\n/**\n * @caution\n *  Must not export anything except `installScaleBreakHelper`\n */\nvar ScaleBreakContextImpl = /** @class */function () {\n  function ScaleBreakContextImpl() {\n    // [CAVEAT]: Should set only by `ScaleBreakContext#setBreaks`!\n    this.breaks = [];\n    // [CAVEAT]: Should update only by `ScaleBreakContext#update`!\n    // They are the values that scaleExtent[0] and scaleExtent[1] are mapped to a numeric axis\n    // that breaks are applied, primarily for optimization of `Scale#normalize`.\n    this._elapsedExtent = [Infinity, -Infinity];\n  }\n  ScaleBreakContextImpl.prototype.setBreaks = function (parsed) {\n    // @ts-ignore\n    this.breaks = parsed.breaks;\n  };\n  /**\n   * [CAVEAT]: Must be called immediately each time scale extent and breaks are updated!\n   */\n  ScaleBreakContextImpl.prototype.update = function (scaleExtent) {\n    updateAxisBreakGapReal(this, scaleExtent);\n    var elapsedExtent = this._elapsedExtent;\n    elapsedExtent[0] = this.elapse(scaleExtent[0]);\n    elapsedExtent[1] = this.elapse(scaleExtent[1]);\n  };\n  ScaleBreakContextImpl.prototype.hasBreaks = function () {\n    return !!this.breaks.length;\n  };\n  /**\n   * When iteratively generating ticks by nice interval, currently the `interval`, which is\n   * calculated by break-elapsed extent span, is probably very small comparing to the original\n   * extent, leading to a large number of iteration and tick generation, even over `safeLimit`.\n   * Thus stepping over breaks is necessary in that loop.\n   *\n   * \"Nice\" should be ensured on ticks when step over the breaks. Thus this method returns\n   * a integer multiple of the \"nice tick interval\".\n   *\n   * This method does little work; it is just for unifying and restricting the behavior.\n   */\n  ScaleBreakContextImpl.prototype.calcNiceTickMultiple = function (tickVal, estimateNiceMultiple) {\n    for (var idx = 0; idx < this.breaks.length; idx++) {\n      var brk = this.breaks[idx];\n      if (brk.vmin < tickVal && tickVal < brk.vmax) {\n        var multiple = estimateNiceMultiple(tickVal, brk.vmax);\n        if (process.env.NODE_ENV !== 'production') {\n          // If not, it may cause dead loop or not nice tick.\n          assert(multiple >= 0 && Math.round(multiple) === multiple);\n        }\n        return multiple;\n      }\n    }\n    return 0;\n  };\n  ScaleBreakContextImpl.prototype.getExtentSpan = function () {\n    return this._elapsedExtent[1] - this._elapsedExtent[0];\n  };\n  ScaleBreakContextImpl.prototype.normalize = function (val) {\n    var elapsedSpan = this._elapsedExtent[1] - this._elapsedExtent[0];\n    // The same logic as `Scale#normalize`.\n    if (elapsedSpan === 0) {\n      return 0.5;\n    }\n    return (this.elapse(val) - this._elapsedExtent[0]) / elapsedSpan;\n  };\n  ScaleBreakContextImpl.prototype.scale = function (val) {\n    return this.unelapse(val * (this._elapsedExtent[1] - this._elapsedExtent[0]) + this._elapsedExtent[0]);\n  };\n  /**\n   * Suppose:\n   *    AXIS_BREAK_LAST_BREAK_END_BASE: 0\n   *    AXIS_BREAK_ELAPSED_BASE: 0\n   *    breaks: [\n   *        {start: -400, end: -300, gap: 27},\n   *        {start: -100, end: 100, gap: 10},\n   *        {start: 200, end: 400, gap: 300},\n   *    ]\n   * The mapping will be:\n   *        |        |\n   *    400 +   ->   +  237\n   *     |  |        |   |  (gap: 300)\n   *    200 +   ->   + -63\n   *        |        |\n   *    100 +   ->   + -163\n   *     |  |        |   |  (gap: 10)\n   *   -100 +   ->   + -173\n   *        |        |\n   *   -300 +   ->   + -373\n   *     |  |        |   |  (gap: 27)\n   *   -400 +   ->   + -400\n   *        |        |\n   *   origianl     elapsed\n   *\n   * Note:\n   *   The mapping has nothing to do with \"scale extent\".\n   */\n  ScaleBreakContextImpl.prototype.elapse = function (val) {\n    // If the value is in the break, return the normalized value in the break\n    var elapsedVal = AXIS_BREAK_ELAPSED_BASE;\n    var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;\n    var stillOver = true;\n    for (var i = 0; i < this.breaks.length; i++) {\n      var brk = this.breaks[i];\n      if (val <= brk.vmax) {\n        if (val > brk.vmin) {\n          elapsedVal += brk.vmin - lastBreakEnd + (val - brk.vmin) / (brk.vmax - brk.vmin) * brk.gapReal;\n        } else {\n          elapsedVal += val - lastBreakEnd;\n        }\n        lastBreakEnd = brk.vmax;\n        stillOver = false;\n        break;\n      }\n      elapsedVal += brk.vmin - lastBreakEnd + brk.gapReal;\n      lastBreakEnd = brk.vmax;\n    }\n    if (stillOver) {\n      elapsedVal += val - lastBreakEnd;\n    }\n    return elapsedVal;\n  };\n  ScaleBreakContextImpl.prototype.unelapse = function (elapsedVal) {\n    var lastElapsedEnd = AXIS_BREAK_ELAPSED_BASE;\n    var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;\n    var stillOver = true;\n    var unelapsedVal = 0;\n    for (var i = 0; i < this.breaks.length; i++) {\n      var brk = this.breaks[i];\n      var elapsedStart = lastElapsedEnd + brk.vmin - lastBreakEnd;\n      var elapsedEnd = elapsedStart + brk.gapReal;\n      if (elapsedVal <= elapsedEnd) {\n        if (elapsedVal > elapsedStart) {\n          unelapsedVal = brk.vmin + (elapsedVal - elapsedStart) / (elapsedEnd - elapsedStart) * (brk.vmax - brk.vmin);\n        } else {\n          unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;\n        }\n        lastBreakEnd = brk.vmax;\n        stillOver = false;\n        break;\n      }\n      lastElapsedEnd = elapsedEnd;\n      lastBreakEnd = brk.vmax;\n    }\n    if (stillOver) {\n      unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;\n    }\n    return unelapsedVal;\n  };\n  return ScaleBreakContextImpl;\n}();\n;\nfunction createScaleBreakContext() {\n  return new ScaleBreakContextImpl();\n}\n// Both can start with any finite value, and are not necessaryily equal. But they need to\n// be the same in `axisBreakElapse` and `axisBreakUnelapse` respectively.\nvar AXIS_BREAK_ELAPSED_BASE = 0;\nvar AXIS_BREAK_LAST_BREAK_END_BASE = 0;\n/**\n * `gapReal` in brkCtx.breaks will be calculated.\n */\nfunction updateAxisBreakGapReal(brkCtx, scaleExtent) {\n  // Considered the effect:\n  //  - Use dataZoom to move some of the breaks outside the extent.\n  //  - Some scenarios that `series.clip: false`.\n  //\n  // How to calculate `prctBrksGapRealSum`:\n  //  Based on the formula:\n  //      xxx.span = brk.vmax - brk.vmin\n  //      xxx.tpPrct.val / xxx.tpAbs.val means ParsedAxisBreak['gapParsed']['val']\n  //      .S/.E means a break that is semi in scaleExtent[0] or scaleExtent[1]\n  //      valP = (\n  //          + (fullyInExtBrksSum.tpAbs.gapReal - fullyInExtBrksSum.tpAbs.span)\n  //          + (semiInExtBrk.S.tpAbs.gapReal - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac\n  //          + (semiInExtBrk.E.tpAbs.gapReal - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac\n  //      )\n  //      valQ = (\n  //          - fullyInExtBrksSum.tpPrct.span\n  //          - semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac\n  //          - semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac\n  //      )\n  //      gapPrctSum = sum(xxx.tpPrct.val)\n  //      gapPrctSum = prctBrksGapRealSum / (\n  //          + (scaleExtent[1] - scaleExtent[0]) + valP + valQ\n  //          + fullyInExtBrksSum.tpPrct.gapReal\n  //          + semiInExtBrk.S.tpPrct.gapReal * semiInExtBrk.S.tpPrct.inExtFrac\n  //          + semiInExtBrk.E.tpPrct.gapReal * semiInExtBrk.E.tpPrct.inExtFrac\n  //      )\n  //  Assume:\n  //      xxx.tpPrct.gapReal = xxx.tpPrct.val / gapPrctSum * prctBrksGapRealSum\n  //         (NOTE: This is not accurate when semi-in-extent break exist because its\n  //         proportion is not linear, but this assumption approximately works.)\n  //  Derived as follows:\n  //      prctBrksGapRealSum = gapPrctSum * ( (scaleExtent[1] - scaleExtent[0]) + valP + valQ )\n  //          / (1\n  //              - fullyInExtBrksSum.tpPrct.val\n  //              - semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac\n  //              - semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac\n  //          )\n  var gapPrctSum = 0;\n  var fullyInExtBrksSum = {\n    tpAbs: {\n      span: 0,\n      val: 0\n    },\n    tpPrct: {\n      span: 0,\n      val: 0\n    }\n  };\n  var init = function () {\n    return {\n      has: false,\n      span: NaN,\n      inExtFrac: NaN,\n      val: NaN\n    };\n  };\n  var semiInExtBrk = {\n    S: {\n      tpAbs: init(),\n      tpPrct: init()\n    },\n    E: {\n      tpAbs: init(),\n      tpPrct: init()\n    }\n  };\n  each(brkCtx.breaks, function (brk) {\n    var gapParsed = brk.gapParsed;\n    if (gapParsed.type === 'tpPrct') {\n      gapPrctSum += gapParsed.val;\n    }\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (clampedBrk) {\n      var vminClamped = clampedBrk.vmin !== brk.vmin;\n      var vmaxClamped = clampedBrk.vmax !== brk.vmax;\n      var clampedSpan = clampedBrk.vmax - clampedBrk.vmin;\n      if (vminClamped && vmaxClamped) {\n        // Do nothing, which simply makes the result `gapReal` cover the entire scaleExtent.\n        // This transform is not consistent with the other cases but practically works.\n      } else if (vminClamped || vmaxClamped) {\n        var sOrE = vminClamped ? 'S' : 'E';\n        semiInExtBrk[sOrE][gapParsed.type].has = true;\n        semiInExtBrk[sOrE][gapParsed.type].span = clampedSpan;\n        semiInExtBrk[sOrE][gapParsed.type].inExtFrac = clampedSpan / (brk.vmax - brk.vmin);\n        semiInExtBrk[sOrE][gapParsed.type].val = gapParsed.val;\n      } else {\n        fullyInExtBrksSum[gapParsed.type].span += clampedSpan;\n        fullyInExtBrksSum[gapParsed.type].val += gapParsed.val;\n      }\n    }\n  });\n  var prctBrksGapRealSum = gapPrctSum * (0 + (scaleExtent[1] - scaleExtent[0]) + (fullyInExtBrksSum.tpAbs.val - fullyInExtBrksSum.tpAbs.span) + (semiInExtBrk.S.tpAbs.has ? (semiInExtBrk.S.tpAbs.val - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac : 0) + (semiInExtBrk.E.tpAbs.has ? (semiInExtBrk.E.tpAbs.val - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac : 0) - fullyInExtBrksSum.tpPrct.span - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac : 0)) / (1 - fullyInExtBrksSum.tpPrct.val - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac : 0));\n  each(brkCtx.breaks, function (brk) {\n    var gapParsed = brk.gapParsed;\n    if (gapParsed.type === 'tpPrct') {\n      brk.gapReal = gapPrctSum !== 0\n      // prctBrksGapRealSum is supposed to be non-negative but add a safe guard\n      ? Math.max(prctBrksGapRealSum, 0) * gapParsed.val / gapPrctSum : 0;\n    }\n    if (gapParsed.type === 'tpAbs') {\n      brk.gapReal = gapParsed.val;\n    }\n    if (brk.gapReal == null) {\n      brk.gapReal = 0;\n    }\n  });\n}\nfunction pruneTicksByBreak(pruneByBreak, ticks, breaks, getValue, interval, scaleExtent) {\n  if (pruneByBreak === 'no') {\n    return;\n  }\n  each(breaks, function (brk) {\n    // break.vmin/vmax that out of extent must not impact the visible of\n    // normal ticks and labels.\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (!clampedBrk) {\n      return;\n    }\n    // Remove some normal ticks to avoid zigzag shapes overlapping with split lines\n    // and to avoid break labels overlapping with normal tick labels (thouth it can\n    // also be avoided by `axisLabel.hideOverlap`).\n    // It's OK to O(n^2) since the number of `ticks` are small.\n    for (var j = ticks.length - 1; j >= 0; j--) {\n      var tick = ticks[j];\n      var val = getValue(tick);\n      // 1. Ensure there is no ticks inside `break.vmin` and `break.vmax`.\n      // 2. Use an empirically gap value here. Theoritically `zigzagAmplitude` is\n      //  supposed to be involved to provide better precision but it will brings\n      //  more complexity. The empirically gap value is conservative because break\n      //  labels and normal tick lables are prone to overlapping.\n      var gap = interval * 3 / 4;\n      if (val > clampedBrk.vmin - gap && val < clampedBrk.vmax + gap && (pruneByBreak !== 'preserve_extent_bound' || val !== scaleExtent[0] && val !== scaleExtent[1])) {\n        ticks.splice(j, 1);\n      }\n    }\n  });\n}\nfunction addBreaksToTicks(\n// The input ticks should be in accending order.\nticks, breaks, scaleExtent,\n// Keep the break ends at the same level to avoid an awkward appearance.\ngetTimeProps) {\n  each(breaks, function (brk) {\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (!clampedBrk) {\n      return;\n    }\n    // - When neight `break.vmin` nor `break.vmax` is in scale extent,\n    //  break label should not be displayed and we do not add them to the result.\n    // - When only one of `break.vmin` and `break.vmax` is inside the extent and the\n    //  other is outsite, we comply with the extent and display only part of the breaks area,\n    //  because the extent might be determined by user settings (such as `axis.min/max`)\n    ticks.push({\n      value: clampedBrk.vmin,\n      \"break\": {\n        type: 'vmin',\n        parsedBreak: clampedBrk\n      },\n      time: getTimeProps ? getTimeProps(clampedBrk) : undefined\n    });\n    // When gap is 0, start tick overlap with end tick, but we still count both of them. Break\n    // area shape can address that overlapping. `axisLabel` need draw both start and end separately,\n    // otherwise it brings complexity to the logic of label overlapping resolving (e.g., when label\n    // rotated), and introduces inconsistency to users in `axisLabel.formatter` between gap is 0 or not.\n    ticks.push({\n      value: clampedBrk.vmax,\n      \"break\": {\n        type: 'vmax',\n        parsedBreak: clampedBrk\n      },\n      time: getTimeProps ? getTimeProps(clampedBrk) : undefined\n    });\n  });\n  if (breaks.length) {\n    ticks.sort(function (a, b) {\n      return a.value - b.value;\n    });\n  }\n}\n/**\n * If break and extent does not intersect, return null/undefined.\n * If the intersection is only a point at scaleExtent[0] or scaleExtent[1], return null/undefined.\n */\nfunction clampBreakByExtent(brk, scaleExtent) {\n  var vmin = Math.max(brk.vmin, scaleExtent[0]);\n  var vmax = Math.min(brk.vmax, scaleExtent[1]);\n  return vmin < vmax || vmin === vmax && vmin > scaleExtent[0] && vmin < scaleExtent[1] ? {\n    vmin: vmin,\n    vmax: vmax,\n    breakOption: brk.breakOption,\n    gapParsed: brk.gapParsed,\n    gapReal: brk.gapReal\n  } : null;\n}\nfunction parseAxisBreakOption(\n// raw user input breaks, retrieved from axis model.\nbreakOptionList, parse, opt) {\n  var parsedBreaks = [];\n  if (!breakOptionList) {\n    return {\n      breaks: parsedBreaks\n    };\n  }\n  function validatePercent(normalizedPercent, msg) {\n    if (normalizedPercent >= 0 && normalizedPercent < 1 - 1e-5) {\n      // Avoid division error.\n      return true;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      error(msg + \" must be >= 0 and < 1, rather than \" + normalizedPercent + \" .\");\n    }\n    return false;\n  }\n  each(breakOptionList, function (brkOption) {\n    if (!brkOption || brkOption.start == null || brkOption.end == null) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('The input axis breaks start/end should not be empty.');\n      }\n      return;\n    }\n    if (brkOption.isExpanded) {\n      return;\n    }\n    var parsedBrk = {\n      breakOption: clone(brkOption),\n      vmin: parse(brkOption.start),\n      vmax: parse(brkOption.end),\n      gapParsed: {\n        type: 'tpAbs',\n        val: 0\n      },\n      gapReal: null\n    };\n    if (brkOption.gap != null) {\n      var isPrct = false;\n      if (isString(brkOption.gap)) {\n        var trimmedGap = trim(brkOption.gap);\n        if (trimmedGap.match(/%$/)) {\n          var normalizedPercent = parseFloat(trimmedGap) / 100;\n          if (!validatePercent(normalizedPercent, 'Percent gap')) {\n            normalizedPercent = 0;\n          }\n          parsedBrk.gapParsed.type = 'tpPrct';\n          parsedBrk.gapParsed.val = normalizedPercent;\n          isPrct = true;\n        }\n      }\n      if (!isPrct) {\n        var absolute = parse(brkOption.gap);\n        if (!isFinite(absolute) || absolute < 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Axis breaks gap must positive finite rather than (\" + brkOption.gap + \").\");\n          }\n          absolute = 0;\n        }\n        parsedBrk.gapParsed.type = 'tpAbs';\n        parsedBrk.gapParsed.val = absolute;\n      }\n    }\n    if (parsedBrk.vmin === parsedBrk.vmax) {\n      parsedBrk.gapParsed.type = 'tpAbs';\n      parsedBrk.gapParsed.val = 0;\n    }\n    if (opt && opt.noNegative) {\n      each(['vmin', 'vmax'], function (se) {\n        if (parsedBrk[se] < 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Axis break.\" + se + \" must not be negative.\");\n          }\n          parsedBrk[se] = 0;\n        }\n      });\n    }\n    // Ascending numerical order is the prerequisite of the calculation in Scale#normalize.\n    // User are allowed to input desending vmin/vmax for simplifying the usage.\n    if (parsedBrk.vmin > parsedBrk.vmax) {\n      var tmp = parsedBrk.vmax;\n      parsedBrk.vmax = parsedBrk.vmin;\n      parsedBrk.vmin = tmp;\n    }\n    parsedBreaks.push(parsedBrk);\n  });\n  // Ascending numerical order is the prerequisite of the calculation in Scale#normalize.\n  parsedBreaks.sort(function (item1, item2) {\n    return item1.vmin - item2.vmin;\n  });\n  // Make sure that the intervals in breaks are not overlap.\n  var lastEnd = -Infinity;\n  each(parsedBreaks, function (brk, idx) {\n    if (lastEnd > brk.vmin) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('Axis breaks must not overlap.');\n      }\n      parsedBreaks[idx] = null;\n    }\n    lastEnd = brk.vmax;\n  });\n  return {\n    breaks: parsedBreaks.filter(function (brk) {\n      return !!brk;\n    })\n  };\n}\nfunction identifyAxisBreak(brk, identifier) {\n  return serializeAxisBreakIdentifier(identifier) === serializeAxisBreakIdentifier(brk);\n}\nfunction serializeAxisBreakIdentifier(identifier) {\n  // We use user input start/end to identify break. Considered cases like `start: new Date(xxx)`,\n  // Theoretically `Scale#parse` should be used here, but not used currently to reduce dependencies,\n  // since simply converting to string happens to be correct.\n  return identifier.start + '_\\0_' + identifier.end;\n}\n/**\n * - A break pair represents `[vmin, vmax]`,\n * - Only both vmin and vmax item exist, they are counted as a pair.\n */\nfunction retrieveAxisBreakPairs(itemList, getVisualAxisBreak, returnIdx) {\n  var idxPairList = [];\n  each(itemList, function (el, idx) {\n    var vBreak = getVisualAxisBreak(el);\n    if (vBreak && vBreak.type === 'vmin') {\n      idxPairList.push([idx]);\n    }\n  });\n  each(itemList, function (el, idx) {\n    var vBreak = getVisualAxisBreak(el);\n    if (vBreak && vBreak.type === 'vmax') {\n      var idxPair = find(idxPairList,\n      // parsedBreak may be changed, can only use breakOption to match them.\n      function (pr) {\n        return identifyAxisBreak(getVisualAxisBreak(itemList[pr[0]]).parsedBreak.breakOption, vBreak.parsedBreak.breakOption);\n      });\n      idxPair && idxPair.push(idx);\n    }\n  });\n  var result = [];\n  each(idxPairList, function (idxPair) {\n    if (idxPair.length === 2) {\n      result.push(returnIdx ? idxPair : [itemList[idxPair[0]], itemList[idxPair[1]]]);\n    }\n  });\n  return result;\n}\nfunction getTicksLogTransformBreak(tick, logBase, logOriginalBreaks, fixRoundingError) {\n  var vBreak;\n  var brkRoundingCriterion;\n  if (tick[\"break\"]) {\n    var brk = tick[\"break\"].parsedBreak;\n    var originalBreak = find(logOriginalBreaks, function (brk) {\n      return identifyAxisBreak(brk.breakOption, tick[\"break\"].parsedBreak.breakOption);\n    });\n    var vmin = fixRoundingError(Math.pow(logBase, brk.vmin), originalBreak.vmin);\n    var vmax = fixRoundingError(Math.pow(logBase, brk.vmax), originalBreak.vmax);\n    var gapParsed = {\n      type: brk.gapParsed.type,\n      val: brk.gapParsed.type === 'tpAbs' ? fixRound(Math.pow(logBase, brk.vmin + brk.gapParsed.val)) - vmin : brk.gapParsed.val\n    };\n    vBreak = {\n      type: tick[\"break\"].type,\n      parsedBreak: {\n        breakOption: brk.breakOption,\n        vmin: vmin,\n        vmax: vmax,\n        gapParsed: gapParsed,\n        gapReal: brk.gapReal\n      }\n    };\n    brkRoundingCriterion = originalBreak[tick[\"break\"].type];\n  }\n  return {\n    brkRoundingCriterion: brkRoundingCriterion,\n    vBreak: vBreak\n  };\n}\nfunction logarithmicParseBreaksFromOption(breakOptionList, logBase, parse) {\n  var opt = {\n    noNegative: true\n  };\n  var parsedOriginal = parseAxisBreakOption(breakOptionList, parse, opt);\n  var parsedLogged = parseAxisBreakOption(breakOptionList, parse, opt);\n  var loggedBase = Math.log(logBase);\n  parsedLogged.breaks = map(parsedLogged.breaks, function (brk) {\n    var vmin = Math.log(brk.vmin) / loggedBase;\n    var vmax = Math.log(brk.vmax) / loggedBase;\n    var gapParsed = {\n      type: brk.gapParsed.type,\n      val: brk.gapParsed.type === 'tpAbs' ? Math.log(brk.vmin + brk.gapParsed.val) / loggedBase - vmin : brk.gapParsed.val\n    };\n    return {\n      vmin: vmin,\n      vmax: vmax,\n      gapParsed: gapParsed,\n      gapReal: brk.gapReal,\n      breakOption: brk.breakOption\n    };\n  });\n  return {\n    parsedOriginal: parsedOriginal,\n    parsedLogged: parsedLogged\n  };\n}\nvar BREAK_MIN_MAX_TO_PARAM = {\n  vmin: 'start',\n  vmax: 'end'\n};\nfunction makeAxisLabelFormatterParamBreak(extraParam, vBreak) {\n  if (vBreak) {\n    extraParam = extraParam || {};\n    extraParam[\"break\"] = {\n      type: BREAK_MIN_MAX_TO_PARAM[vBreak.type],\n      start: vBreak.parsedBreak.vmin,\n      end: vBreak.parsedBreak.vmax\n    };\n  }\n  return extraParam;\n}\nexport function installScaleBreakHelper() {\n  registerScaleBreakHelperImpl({\n    createScaleBreakContext: createScaleBreakContext,\n    pruneTicksByBreak: pruneTicksByBreak,\n    addBreaksToTicks: addBreaksToTicks,\n    parseAxisBreakOption: parseAxisBreakOption,\n    identifyAxisBreak: identifyAxisBreak,\n    serializeAxisBreakIdentifier: serializeAxisBreakIdentifier,\n    retrieveAxisBreakPairs: retrieveAxisBreakPairs,\n    getTicksLogTransformBreak: getTicksLogTransformBreak,\n    logarithmicParseBreaksFromOption: logarithmicParseBreaksFromOption,\n    makeAxisLabelFormatterParamBreak: makeAxisLabelFormatterParamBreak\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}