{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport Path from 'zrender/lib/graphic/Path.js';\nimport Group from 'zrender/lib/graphic/Group.js';\nimport { extend, each, map } from 'zrender/lib/core/util.js';\nimport { Rect, Sector, updateProps, initProps, removeElementWithFadeOut, traverseElements } from '../../util/graphic.js';\nimport { getECData } from '../../util/innerStore.js';\nimport { setStatesStylesFromModel, toggleHoverEmphasis } from '../../util/states.js';\nimport { setLabelStyle, getLabelStatesModels, setLabelValueAnimation, labelInner } from '../../label/labelStyle.js';\nimport { throttle } from '../../util/throttle.js';\nimport { createClipPath } from '../helper/createClipPathFromCoordSys.js';\nimport Sausage from '../../util/shape/sausage.js';\nimport ChartView from '../../view/Chart.js';\nimport { isCoordinateSystemType } from '../../coord/CoordinateSystem.js';\nimport { getDefaultLabel, getDefaultInterpolatedLabel } from '../helper/labelHelper.js';\nimport { warn } from '../../util/log.js';\nimport { createSectorCalculateTextPosition, setSectorTextRotation } from '../../label/sectorLabel.js';\nimport { saveOldStyle } from '../../animation/basicTransition.js';\nimport { getSectorCornerRadius } from '../helper/sectorHelper.js';\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nfunction getClipArea(coord, data) {\n  var coordSysClipArea = coord.getArea && coord.getArea();\n  if (isCoordinateSystemType(coord, 'cartesian2d')) {\n    var baseAxis = coord.getBaseAxis();\n    // When boundaryGap is false or using time axis. bar may exceed the grid.\n    // We should not clip this part.\n    // See test/bar2.html\n    if (baseAxis.type !== 'category' || !baseAxis.onBand) {\n      var expandWidth = data.getLayout('bandWidth');\n      if (baseAxis.isHorizontal()) {\n        coordSysClipArea.x -= expandWidth;\n        coordSysClipArea.width += expandWidth * 2;\n      } else {\n        coordSysClipArea.y -= expandWidth;\n        coordSysClipArea.height += expandWidth * 2;\n      }\n    }\n  }\n  return coordSysClipArea;\n}\nvar BarView = /** @class */function (_super) {\n  __extends(BarView, _super);\n  function BarView() {\n    var _this = _super.call(this) || this;\n    _this.type = BarView.type;\n    _this._isFirstFrame = true;\n    return _this;\n  }\n  BarView.prototype.render = function (seriesModel, ecModel, api, payload) {\n    this._model = seriesModel;\n    this._removeOnRenderedListener(api);\n    this._updateDrawMode(seriesModel);\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      // Clear previously rendered progressive elements.\n      this._progressiveEls = null;\n      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn('Only cartesian2d and polar supported for bar.');\n    }\n  };\n  BarView.prototype.incrementalPrepareRender = function (seriesModel) {\n    this._clear();\n    this._updateDrawMode(seriesModel);\n    // incremental also need to clip, otherwise might be overlow.\n    // But must not set clip in each frame, otherwise all of the children will be marked redraw.\n    this._updateLargeClip(seriesModel);\n  };\n  BarView.prototype.incrementalRender = function (params, seriesModel) {\n    // Reset\n    this._progressiveEls = [];\n    // Do not support progressive in normal mode.\n    this._incrementalRenderLarge(params, seriesModel);\n  };\n  BarView.prototype.eachRendered = function (cb) {\n    traverseElements(this._progressiveEls || this.group, cb);\n  };\n  BarView.prototype._updateDrawMode = function (seriesModel) {\n    var isLargeDraw = seriesModel.pipelineContext.large;\n    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {\n      this._isLargeDraw = isLargeDraw;\n      this._clear();\n    }\n  };\n  BarView.prototype._renderNormal = function (seriesModel, ecModel, api, payload) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);\n    if (realtimeSortCfg) {\n      this._enableRealtimeSort(realtimeSortCfg, data, api);\n    }\n    var needsClip = seriesModel.get('clip', true) || realtimeSortCfg;\n    var coordSysClipArea = getClipArea(coord, data);\n    // If there is clipPath created in large mode. Remove it.\n    group.removeClipPath();\n    // We don't use clipPath in normal mode because we needs a perfect animation\n    // And don't want the label are clipped.\n    var roundCap = seriesModel.get('roundCap', true);\n    var drawBackground = seriesModel.get('showBackground', true);\n    var backgroundModel = seriesModel.getModel('backgroundStyle');\n    var barBorderRadius = backgroundModel.get('borderRadius') || 0;\n    var bgEls = [];\n    var oldBgEls = this._backgroundEls;\n    var isInitSort = payload && payload.isInitSort;\n    var isChangeOrder = payload && payload.type === 'changeAxisOrder';\n    function createBackground(dataIndex) {\n      var bgLayout = getLayout[coord.type](data, dataIndex);\n      if (!bgLayout) {\n        return null;\n      }\n      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);\n      bgEl.useStyle(backgroundModel.getItemStyle());\n      // Only cartesian2d support borderRadius.\n      if (coord.type === 'cartesian2d') {\n        bgEl.setShape('r', barBorderRadius);\n      } else {\n        bgEl.setShape('cornerRadius', barBorderRadius);\n      }\n      bgEls[dataIndex] = bgEl;\n      return bgEl;\n    }\n    ;\n    data.diff(oldData).add(function (dataIndex) {\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      if (!layout) {\n        return;\n      }\n      if (drawBackground) {\n        createBackground(dataIndex);\n      }\n      // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in \"axisProxy\".\n      if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout)) {\n        return;\n      }\n      var isClipped = false;\n      if (needsClip) {\n        // Clip will modify the layout params.\n        // And return a boolean to determine if the shape are fully clipped.\n        isClipped = clip[coord.type](coordSysClipArea, layout);\n      }\n      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);\n      if (realtimeSortCfg) {\n        /**\n         * Force label animation because even if the element is\n         * ignored because it's clipped, it may not be clipped after\n         * changing order. Then, if not using forceLabelAnimation,\n         * the label animation was never started, in which case,\n         * the label will be the final value and doesn't have label\n         * animation.\n         */\n        el.forceLabelAnimation = true;\n      }\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n      if (isInitSort) {\n        el.attr({\n          shape: layout\n        });\n      } else if (realtimeSortCfg) {\n        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, dataIndex, isHorizontalOrRadial, false, false);\n      } else {\n        initProps(el, {\n          shape: layout\n        }, seriesModel, dataIndex);\n      }\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      el.ignore = isClipped;\n    }).update(function (newIndex, oldIndex) {\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n      if (!layout) {\n        return;\n      }\n      if (drawBackground) {\n        var bgEl = void 0;\n        if (oldBgEls.length === 0) {\n          bgEl = createBackground(oldIndex);\n        } else {\n          bgEl = oldBgEls[oldIndex];\n          bgEl.useStyle(backgroundModel.getItemStyle());\n          // Only cartesian2d support borderRadius.\n          if (coord.type === 'cartesian2d') {\n            bgEl.setShape('r', barBorderRadius);\n          } else {\n            bgEl.setShape('cornerRadius', barBorderRadius);\n          }\n          bgEls[newIndex] = bgEl;\n        }\n        var bgLayout = getLayout[coord.type](data, newIndex);\n        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);\n        updateProps(bgEl, {\n          shape: shape\n        }, animationModel, newIndex);\n      }\n      var el = oldData.getItemGraphicEl(oldIndex);\n      if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout)) {\n        group.remove(el);\n        return;\n      }\n      var isClipped = false;\n      if (needsClip) {\n        isClipped = clip[coord.type](coordSysClipArea, layout);\n        if (isClipped) {\n          group.remove(el);\n        }\n      }\n      var roundCapChanged = el && (el.type === 'sector' && roundCap || el.type === 'sausage' && !roundCap);\n      if (roundCapChanged) {\n        // roundCap changed, there is no way to use animation from a `sector` to a `sausage` shape,\n        // so remove the old one and create a new shape\n        el && removeElementWithFadeOut(el, seriesModel, oldIndex);\n        el = null;\n      }\n      if (!el) {\n        el = elementCreator[coord.type](seriesModel, data, newIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, true, roundCap);\n      } else {\n        saveOldStyle(el);\n      }\n      if (realtimeSortCfg) {\n        el.forceLabelAnimation = true;\n      }\n      if (isChangeOrder) {\n        var textEl = el.getTextContent();\n        if (textEl) {\n          var labelInnerStore = labelInner(textEl);\n          if (labelInnerStore.prevValue != null) {\n            /**\n             * Set preValue to be value so that no new label\n             * should be started, otherwise, it will take a full\n             * `animationDurationUpdate` time to finish the\n             * animation, which is not expected.\n             */\n            labelInnerStore.prevValue = labelInnerStore.value;\n          }\n        }\n      }\n      // Not change anything if only order changed.\n      // Especially not change label.\n      else {\n        updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n      }\n      if (isInitSort) {\n        el.attr({\n          shape: layout\n        });\n      } else if (realtimeSortCfg) {\n        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, newIndex, isHorizontalOrRadial, true, isChangeOrder);\n      } else {\n        updateProps(el, {\n          shape: layout\n        }, seriesModel, newIndex, null);\n      }\n      data.setItemGraphicEl(newIndex, el);\n      el.ignore = isClipped;\n      group.add(el);\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n      el && removeElementWithFadeOut(el, seriesModel, dataIndex);\n    }).execute();\n    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group());\n    bgGroup.removeAll();\n    for (var i = 0; i < bgEls.length; ++i) {\n      bgGroup.add(bgEls[i]);\n    }\n    group.add(bgGroup);\n    this._backgroundEls = bgEls;\n    this._data = data;\n  };\n  BarView.prototype._renderLarge = function (seriesModel, ecModel, api) {\n    this._clear();\n    createLarge(seriesModel, this.group);\n    this._updateLargeClip(seriesModel);\n  };\n  BarView.prototype._incrementalRenderLarge = function (params, seriesModel) {\n    this._removeBackground();\n    createLarge(seriesModel, this.group, this._progressiveEls, true);\n  };\n  BarView.prototype._updateLargeClip = function (seriesModel) {\n    // Use clipPath in large mode.\n    var clipPath = seriesModel.get('clip', true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);\n    var group = this.group;\n    if (clipPath) {\n      group.setClipPath(clipPath);\n    } else {\n      group.removeClipPath();\n    }\n  };\n  BarView.prototype._enableRealtimeSort = function (realtimeSortCfg, data, api) {\n    var _this = this;\n    // If no data in the first frame, wait for data to initSort\n    if (!data.count()) {\n      return;\n    }\n    var baseAxis = realtimeSortCfg.baseAxis;\n    if (this._isFirstFrame) {\n      this._dispatchInitSort(data, realtimeSortCfg, api);\n      this._isFirstFrame = false;\n    } else {\n      var orderMapping_1 = function (idx) {\n        var el = data.getItemGraphicEl(idx);\n        var shape = el && el.shape;\n        return shape &&\n        // The result should be consistent with the initial sort by data value.\n        // Do not support the case that both positive and negative exist.\n        Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width)\n        // If data is NaN, shape.xxx may be NaN, so use || 0 here in case\n        || 0;\n      };\n      this._onRendered = function () {\n        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);\n      };\n      api.getZr().on('rendered', this._onRendered);\n    }\n  };\n  BarView.prototype._dataSort = function (data, baseAxis, orderMapping) {\n    var info = [];\n    data.each(data.mapDimension(baseAxis.dim), function (ordinalNumber, dataIdx) {\n      var mappedValue = orderMapping(dataIdx);\n      mappedValue = mappedValue == null ? NaN : mappedValue;\n      info.push({\n        dataIndex: dataIdx,\n        mappedValue: mappedValue,\n        ordinalNumber: ordinalNumber\n      });\n    });\n    info.sort(function (a, b) {\n      // If NaN, it will be treated as min val.\n      return b.mappedValue - a.mappedValue;\n    });\n    return {\n      ordinalNumbers: map(info, function (item) {\n        return item.ordinalNumber;\n      })\n    };\n  };\n  BarView.prototype._isOrderChangedWithinSameData = function (data, orderMapping, baseAxis) {\n    var scale = baseAxis.scale;\n    var ordinalDataDim = data.mapDimension(baseAxis.dim);\n    var lastValue = Number.MAX_VALUE;\n    for (var tickNum = 0, len = scale.getOrdinalMeta().categories.length; tickNum < len; ++tickNum) {\n      var rawIdx = data.rawIndexOf(ordinalDataDim, scale.getRawOrdinalNumber(tickNum));\n      var value = rawIdx < 0\n      // If some tick have no bar, the tick will be treated as min.\n      ? Number.MIN_VALUE\n      // PENDING: if dataZoom on baseAxis exits, is it a performance issue?\n      : orderMapping(data.indexOfRawIndex(rawIdx));\n      if (value > lastValue) {\n        return true;\n      }\n      lastValue = value;\n    }\n    return false;\n  };\n  /*\n   * Consider the case when A and B changed order, whose representing\n   * bars are both out of sight, we don't wish to trigger reorder action\n   * as long as the order in the view doesn't change.\n   */\n  BarView.prototype._isOrderDifferentInView = function (orderInfo, baseAxis) {\n    var scale = baseAxis.scale;\n    var extent = scale.getExtent();\n    var tickNum = Math.max(0, extent[0]);\n    var tickMax = Math.min(extent[1], scale.getOrdinalMeta().categories.length - 1);\n    for (; tickNum <= tickMax; ++tickNum) {\n      if (orderInfo.ordinalNumbers[tickNum] !== scale.getRawOrdinalNumber(tickNum)) {\n        return true;\n      }\n    }\n  };\n  BarView.prototype._updateSortWithinSameData = function (data, orderMapping, baseAxis, api) {\n    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {\n      return;\n    }\n    var sortInfo = this._dataSort(data, baseAxis, orderMapping);\n    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {\n      this._removeOnRenderedListener(api);\n      api.dispatchAction({\n        type: 'changeAxisOrder',\n        componentType: baseAxis.dim + 'Axis',\n        axisId: baseAxis.index,\n        sortInfo: sortInfo\n      });\n    }\n  };\n  BarView.prototype._dispatchInitSort = function (data, realtimeSortCfg, api) {\n    var baseAxis = realtimeSortCfg.baseAxis;\n    var sortResult = this._dataSort(data, baseAxis, function (dataIdx) {\n      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);\n    });\n    api.dispatchAction({\n      type: 'changeAxisOrder',\n      componentType: baseAxis.dim + 'Axis',\n      isInitSort: true,\n      axisId: baseAxis.index,\n      sortInfo: sortResult\n    });\n  };\n  BarView.prototype.remove = function (ecModel, api) {\n    this._clear(this._model);\n    this._removeOnRenderedListener(api);\n  };\n  BarView.prototype.dispose = function (ecModel, api) {\n    this._removeOnRenderedListener(api);\n  };\n  BarView.prototype._removeOnRenderedListener = function (api) {\n    if (this._onRendered) {\n      api.getZr().off('rendered', this._onRendered);\n      this._onRendered = null;\n    }\n  };\n  BarView.prototype._clear = function (model) {\n    var group = this.group;\n    var data = this._data;\n    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {\n      this._removeBackground();\n      this._backgroundEls = [];\n      data.eachItemGraphicEl(function (el) {\n        removeElementWithFadeOut(el, model, getECData(el).dataIndex);\n      });\n    } else {\n      group.removeAll();\n    }\n    this._data = null;\n    this._isFirstFrame = true;\n  };\n  BarView.prototype._removeBackground = function () {\n    this.group.remove(this._backgroundGroup);\n    this._backgroundGroup = null;\n  };\n  BarView.type = 'bar';\n  return BarView;\n}(ChartView);\nvar clip = {\n  cartesian2d: function (coordSysBoundingRect, layout) {\n    var signWidth = layout.width < 0 ? -1 : 1;\n    var signHeight = layout.height < 0 ? -1 : 1;\n    // Needs positive width and height\n    if (signWidth < 0) {\n      layout.x += layout.width;\n      layout.width = -layout.width;\n    }\n    if (signHeight < 0) {\n      layout.y += layout.height;\n      layout.height = -layout.height;\n    }\n    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;\n    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;\n    var x = mathMax(layout.x, coordSysBoundingRect.x);\n    var x2 = mathMin(layout.x + layout.width, coordSysX2);\n    var y = mathMax(layout.y, coordSysBoundingRect.y);\n    var y2 = mathMin(layout.y + layout.height, coordSysY2);\n    var xClipped = x2 < x;\n    var yClipped = y2 < y;\n    // When xClipped or yClipped, the element will be marked as `ignore`.\n    // But we should also place the element at the edge of the coord sys bounding rect.\n    // Because if data changed and the bar shows again, its transition animation\n    // will begin at this place.\n    layout.x = xClipped && x > coordSysX2 ? x2 : x;\n    layout.y = yClipped && y > coordSysY2 ? y2 : y;\n    layout.width = xClipped ? 0 : x2 - x;\n    layout.height = yClipped ? 0 : y2 - y;\n    // Reverse back\n    if (signWidth < 0) {\n      layout.x += layout.width;\n      layout.width = -layout.width;\n    }\n    if (signHeight < 0) {\n      layout.y += layout.height;\n      layout.height = -layout.height;\n    }\n    return xClipped || yClipped;\n  },\n  polar: function (coordSysClipArea, layout) {\n    var signR = layout.r0 <= layout.r ? 1 : -1;\n    // Make sure r is larger than r0\n    if (signR < 0) {\n      var tmp = layout.r;\n      layout.r = layout.r0;\n      layout.r0 = tmp;\n    }\n    var r = mathMin(layout.r, coordSysClipArea.r);\n    var r0 = mathMax(layout.r0, coordSysClipArea.r0);\n    layout.r = r;\n    layout.r0 = r0;\n    var clipped = r - r0 < 0;\n    // Reverse back\n    if (signR < 0) {\n      var tmp = layout.r;\n      layout.r = layout.r0;\n      layout.r0 = tmp;\n    }\n    return clipped;\n  }\n};\nvar elementCreator = {\n  cartesian2d: function (seriesModel, data, newIndex, layout, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {\n    var rect = new Rect({\n      shape: extend({}, layout),\n      z2: 1\n    });\n    rect.__dataIndex = newIndex;\n    rect.name = 'item';\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      rectShape[animateProperty] = 0;\n    }\n    return rect;\n  },\n  polar: function (seriesModel, data, newIndex, layout, isRadial, animationModel, axisModel, isUpdate, roundCap) {\n    var ShapeClass = !isRadial && roundCap ? Sausage : Sector;\n    var sector = new ShapeClass({\n      shape: layout,\n      z2: 1\n    });\n    sector.name = 'item';\n    var positionMap = createPolarPositionMapping(isRadial);\n    sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {\n      isRoundCap: ShapeClass === Sausage\n    });\n    // Animation\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? layout.r0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      (isUpdate ? updateProps : initProps)(sector, {\n        shape: animateTarget\n        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue\n      }, animationModel);\n    }\n    return sector;\n  }\n};\nfunction shouldRealtimeSort(seriesModel, coordSys) {\n  var realtimeSortOption = seriesModel.get('realtimeSort', true);\n  var baseAxis = coordSys.getBaseAxis();\n  if (process.env.NODE_ENV !== 'production') {\n    if (realtimeSortOption) {\n      if (baseAxis.type !== 'category') {\n        warn('`realtimeSort` will not work because this bar series is not based on a category axis.');\n      }\n      if (coordSys.type !== 'cartesian2d') {\n        warn('`realtimeSort` will not work because this bar series is not on cartesian2d.');\n      }\n    }\n  }\n  if (realtimeSortOption && baseAxis.type === 'category' && coordSys.type === 'cartesian2d') {\n    return {\n      baseAxis: baseAxis,\n      otherAxis: coordSys.getOtherAxis(baseAxis)\n    };\n  }\n}\nfunction updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout, newIndex, isHorizontal, isUpdate, isChangeOrder) {\n  var seriesTarget;\n  var axisTarget;\n  if (isHorizontal) {\n    axisTarget = {\n      x: layout.x,\n      width: layout.width\n    };\n    seriesTarget = {\n      y: layout.y,\n      height: layout.height\n    };\n  } else {\n    axisTarget = {\n      y: layout.y,\n      height: layout.height\n    };\n    seriesTarget = {\n      x: layout.x,\n      width: layout.width\n    };\n  }\n  if (!isChangeOrder) {\n    // Keep the original growth animation if only axis order changed.\n    // Not start a new animation.\n    (isUpdate ? updateProps : initProps)(el, {\n      shape: seriesTarget\n    }, seriesAnimationModel, newIndex, null);\n  }\n  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;\n  (isUpdate ? updateProps : initProps)(el, {\n    shape: axisTarget\n  }, axisAnimationModel, newIndex);\n}\nfunction checkPropertiesNotValid(obj, props) {\n  for (var i = 0; i < props.length; i++) {\n    if (!isFinite(obj[props[i]])) {\n      return true;\n    }\n  }\n  return false;\n}\nvar rectPropties = ['x', 'y', 'width', 'height'];\nvar polarPropties = ['cx', 'cy', 'r', 'startAngle', 'endAngle'];\nvar isValidLayout = {\n  cartesian2d: function (layout) {\n    return !checkPropertiesNotValid(layout, rectPropties);\n  },\n  polar: function (layout) {\n    return !checkPropertiesNotValid(layout, polarPropties);\n  }\n};\nvar getLayout = {\n  // itemModel is only used to get borderWidth, which is not needed\n  // when calculating bar background layout.\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    if (!layout) {\n      return null;\n    }\n    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0;\n    // fix layout with lineWidth\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle,\n      clockwise: layout.clockwise\n    };\n  }\n};\nfunction isZeroOnPolar(layout) {\n  return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;\n}\nfunction createPolarPositionMapping(isRadial) {\n  return function (isRadial) {\n    var arcOrAngle = isRadial ? 'Arc' : 'Angle';\n    return function (position) {\n      switch (position) {\n        case 'start':\n        case 'insideStart':\n        case 'end':\n        case 'insideEnd':\n          return position + arcOrAngle;\n        default:\n          return position;\n      }\n    };\n  }(isRadial);\n}\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, isPolar) {\n  var style = data.getItemVisual(dataIndex, 'style');\n  if (!isPolar) {\n    var borderRadius = itemModel.get(['itemStyle', 'borderRadius']) || 0;\n    el.setShape('r', borderRadius);\n  } else if (!seriesModel.get('roundCap')) {\n    var sectorShape = el.shape;\n    var cornerRadius = getSectorCornerRadius(itemModel.getModel('itemStyle'), sectorShape, true);\n    extend(sectorShape, cornerRadius);\n    el.setShape(sectorShape);\n  }\n  el.useStyle(style);\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout.r >= layout.r0 ? 'endArc' : 'startArc' : layout.endAngle >= layout.startAngle ? 'endAngle' : 'startAngle' : isHorizontalOrRadial ? layout.height >= 0 ? 'bottom' : 'top' : layout.width >= 0 ? 'right' : 'left';\n  var labelStatesModels = getLabelStatesModels(itemModel);\n  setLabelStyle(el, labelStatesModels, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),\n    inheritColor: style.fill,\n    defaultOpacity: style.opacity,\n    defaultOutsidePosition: labelPositionOutside\n  });\n  var label = el.getTextContent();\n  if (isPolar && label) {\n    var position = itemModel.get(['label', 'position']);\n    el.textConfig.inside = position === 'middle' ? true : null;\n    setSectorTextRotation(el, position === 'outside' ? labelPositionOutside : position, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(['label', 'rotate']));\n  }\n  setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function (value) {\n    return getDefaultInterpolatedLabel(data, value);\n  });\n  var emphasisModel = itemModel.getModel(['emphasis']);\n  toggleHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n  setStatesStylesFromModel(el, itemModel);\n  if (isZeroOnPolar(layout)) {\n    el.style.fill = 'none';\n    el.style.stroke = 'none';\n    each(el.states, function (state) {\n      if (state.style) {\n        state.style.fill = state.style.stroke = 'none';\n      }\n    });\n  }\n}\n// In case width or height are too small.\nfunction getLineWidth(itemModel, rawLayout) {\n  // Has no border.\n  var borderColor = itemModel.get(['itemStyle', 'borderColor']);\n  if (!borderColor || borderColor === 'none') {\n    return 0;\n  }\n  var lineWidth = itemModel.get(['itemStyle', 'borderWidth']) || 0;\n  // width or height may be NaN for empty data\n  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);\n  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);\n  return Math.min(lineWidth, width, height);\n}\nvar LagePathShape = /** @class */function () {\n  function LagePathShape() {}\n  return LagePathShape;\n}();\nvar LargePath = /** @class */function (_super) {\n  __extends(LargePath, _super);\n  function LargePath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'largeBar';\n    return _this;\n  }\n  LargePath.prototype.getDefaultShape = function () {\n    return new LagePathShape();\n  };\n  LargePath.prototype.buildPath = function (ctx, shape) {\n    // Drawing lines is more efficient than drawing\n    // a whole line or drawing rects.\n    var points = shape.points;\n    var baseDimIdx = this.baseDimIdx;\n    var valueDimIdx = 1 - this.baseDimIdx;\n    var startPoint = [];\n    var size = [];\n    var barWidth = this.barWidth;\n    for (var i = 0; i < points.length; i += 3) {\n      size[baseDimIdx] = barWidth;\n      size[valueDimIdx] = points[i + 2];\n      startPoint[baseDimIdx] = points[i + baseDimIdx];\n      startPoint[valueDimIdx] = points[i + valueDimIdx];\n      ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);\n    }\n  };\n  return LargePath;\n}(Path);\nfunction createLarge(seriesModel, group, progressiveEls, incremental) {\n  // TODO support polar\n  var data = seriesModel.getData();\n  var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;\n  var largeDataIndices = data.getLayout('largeDataIndices');\n  var barWidth = data.getLayout('size');\n  var backgroundModel = seriesModel.getModel('backgroundStyle');\n  var bgPoints = data.getLayout('largeBackgroundPoints');\n  if (bgPoints) {\n    var bgEl = new LargePath({\n      shape: {\n        points: bgPoints\n      },\n      incremental: !!incremental,\n      silent: true,\n      z2: 0\n    });\n    bgEl.baseDimIdx = baseDimIdx;\n    bgEl.largeDataIndices = largeDataIndices;\n    bgEl.barWidth = barWidth;\n    bgEl.useStyle(backgroundModel.getItemStyle());\n    group.add(bgEl);\n    progressiveEls && progressiveEls.push(bgEl);\n  }\n  var el = new LargePath({\n    shape: {\n      points: data.getLayout('largePoints')\n    },\n    incremental: !!incremental,\n    ignoreCoarsePointer: true,\n    z2: 1\n  });\n  el.baseDimIdx = baseDimIdx;\n  el.largeDataIndices = largeDataIndices;\n  el.barWidth = barWidth;\n  group.add(el);\n  el.useStyle(data.getVisual('style'));\n  // Stroke is rendered first to avoid overlapping with fill\n  el.style.stroke = null;\n  // Enable tooltip and user mouse/touch event handlers.\n  getECData(el).seriesIndex = seriesModel.seriesIndex;\n  if (!seriesModel.get('silent')) {\n    el.on('mousedown', largePathUpdateDataIndex);\n    el.on('mousemove', largePathUpdateDataIndex);\n  }\n  progressiveEls && progressiveEls.push(el);\n}\n// Use throttle to avoid frequently traverse to find dataIndex.\nvar largePathUpdateDataIndex = throttle(function (event) {\n  var largePath = this;\n  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);\n  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;\n}, 30, false);\nfunction largePathFindDataIndex(largePath, x, y) {\n  var baseDimIdx = largePath.baseDimIdx;\n  var valueDimIdx = 1 - baseDimIdx;\n  var points = largePath.shape.points;\n  var largeDataIndices = largePath.largeDataIndices;\n  var startPoint = [];\n  var size = [];\n  var barWidth = largePath.barWidth;\n  for (var i = 0, len = points.length / 3; i < len; i++) {\n    var ii = i * 3;\n    size[baseDimIdx] = barWidth;\n    size[valueDimIdx] = points[ii + 2];\n    startPoint[baseDimIdx] = points[ii + baseDimIdx];\n    startPoint[valueDimIdx] = points[ii + valueDimIdx];\n    if (size[valueDimIdx] < 0) {\n      startPoint[valueDimIdx] += size[valueDimIdx];\n      size[valueDimIdx] = -size[valueDimIdx];\n    }\n    if (x >= startPoint[0] && x <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) {\n      return largeDataIndices[i];\n    }\n  }\n  return -1;\n}\nfunction createBackgroundShape(isHorizontalOrRadial, layout, coord) {\n  if (isCoordinateSystemType(coord, 'cartesian2d')) {\n    var rectShape = layout;\n    var coordLayout = coord.getArea();\n    return {\n      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,\n      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,\n      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,\n      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height\n    };\n  } else {\n    var coordLayout = coord.getArea();\n    var sectorShape = layout;\n    return {\n      cx: coordLayout.cx,\n      cy: coordLayout.cy,\n      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,\n      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,\n      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,\n      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2\n    };\n  }\n}\nfunction createBackgroundEl(coord, isHorizontalOrRadial, layout) {\n  var ElementClz = coord.type === 'polar' ? Sector : Rect;\n  return new ElementClz({\n    shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),\n    silent: true,\n    z2: 0\n  });\n}\nexport default BarView;","map":{"version":3,"names":["__extends","Path","Group","extend","each","map","Rect","Sector","updateProps","initProps","removeElementWithFadeOut","traverseElements","getECData","setStatesStylesFromModel","toggleHoverEmphasis","setLabelStyle","getLabelStatesModels","setLabelValueAnimation","labelInner","throttle","createClipPath","Sausage","ChartView","isCoordinateSystemType","getDefaultLabel","getDefaultInterpolatedLabel","warn","createSectorCalculateTextPosition","setSectorTextRotation","saveOldStyle","getSectorCornerRadius","mathMax","Math","max","mathMin","min","getClipArea","coord","data","coordSysClipArea","getArea","baseAxis","getBaseAxis","type","onBand","expandWidth","getLayout","isHorizontal","x","width","y","height","BarView","_super","_this","call","_isFirstFrame","prototype","render","seriesModel","ecModel","api","payload","_model","_removeOnRenderedListener","_updateDrawMode","coordinateSystemType","get","_progressiveEls","_isLargeDraw","_renderLarge","_renderNormal","process","env","NODE_ENV","incrementalPrepareRender","_clear","_updateLargeClip","incrementalRender","params","_incrementalRenderLarge","eachRendered","cb","group","isLargeDraw","pipelineContext","large","getData","oldData","_data","coordinateSystem","isHorizontalOrRadial","dim","animationModel","isAnimationEnabled","realtimeSortCfg","shouldRealtimeSort","_enableRealtimeSort","needsClip","removeClipPath","roundCap","drawBackground","backgroundModel","getModel","barBorderRadius","bgEls","oldBgEls","_backgroundEls","isInitSort","isChangeOrder","createBackground","dataIndex","bgLayout","bgEl","createBackgroundEl","useStyle","getItemStyle","setShape","diff","add","itemModel","getItemModel","layout","hasValue","isValidLayout","isClipped","clip","el","elementCreator","model","forceLabelAnimation","updateStyle","attr","shape","updateRealtimeAnimation","setItemGraphicEl","ignore","update","newIndex","oldIndex","length","createBackgroundShape","getItemGraphicEl","remove","roundCapChanged","textEl","getTextContent","labelInnerStore","prevValue","value","execute","bgGroup","_backgroundGroup","removeAll","i","createLarge","_removeBackground","clipPath","setClipPath","count","_dispatchInitSort","orderMapping_1","idx","abs","_onRendered","_updateSortWithinSameData","getZr","on","_dataSort","orderMapping","info","mapDimension","ordinalNumber","dataIdx","mappedValue","NaN","push","sort","a","b","ordinalNumbers","item","_isOrderChangedWithinSameData","scale","ordinalDataDim","lastValue","Number","MAX_VALUE","tickNum","len","getOrdinalMeta","categories","rawIdx","rawIndexOf","getRawOrdinalNumber","MIN_VALUE","indexOfRawIndex","_isOrderDifferentInView","orderInfo","extent","getExtent","tickMax","sortInfo","dispatchAction","componentType","axisId","index","sortResult","otherAxis","dispose","off","eachItemGraphicEl","cartesian2d","coordSysBoundingRect","signWidth","signHeight","coordSysX2","coordSysY2","x2","y2","xClipped","yClipped","polar","signR","r0","r","tmp","clipped","axisModel","isUpdate","rect","z2","__dataIndex","name","rectShape","animateProperty","isRadial","ShapeClass","sector","positionMap","createPolarPositionMapping","calculateTextPosition","isRoundCap","sectorShape","animateTarget","startAngle","coordSys","realtimeSortOption","getOtherAxis","seriesAnimationModel","seriesTarget","axisTarget","axisAnimationModel","checkPropertiesNotValid","obj","props","isFinite","rectPropties","polarPropties","getItemLayout","fixedLineWidth","getLineWidth","signX","signY","cx","cy","endAngle","clockwise","isZeroOnPolar","arcOrAngle","position","isPolar","style","getItemVisual","borderRadius","cornerRadius","cursorStyle","getShallow","labelPositionOutside","labelStatesModels","labelFetcher","labelDataIndex","defaultText","inheritColor","fill","defaultOpacity","opacity","defaultOutsidePosition","label","textConfig","inside","getRawValue","emphasisModel","stroke","states","state","rawLayout","borderColor","lineWidth","isNaN","LagePathShape","LargePath","opts","getDefaultShape","buildPath","ctx","points","baseDimIdx","valueDimIdx","startPoint","size","barWidth","progressiveEls","incremental","largeDataIndices","bgPoints","silent","ignoreCoarsePointer","getVisual","seriesIndex","largePathUpdateDataIndex","event","largePath","largePathFindDataIndex","offsetX","offsetY","ii","coordLayout","PI","ElementClz"],"sources":["D:/Program Files/JetBrains/IDEAProject/springboot-vue-wms_test/vuedemo2/node_modules/echarts/lib/chart/bar/BarView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport Path from 'zrender/lib/graphic/Path.js';\nimport Group from 'zrender/lib/graphic/Group.js';\nimport { extend, each, map } from 'zrender/lib/core/util.js';\nimport { Rect, Sector, updateProps, initProps, removeElementWithFadeOut, traverseElements } from '../../util/graphic.js';\nimport { getECData } from '../../util/innerStore.js';\nimport { setStatesStylesFromModel, toggleHoverEmphasis } from '../../util/states.js';\nimport { setLabelStyle, getLabelStatesModels, setLabelValueAnimation, labelInner } from '../../label/labelStyle.js';\nimport { throttle } from '../../util/throttle.js';\nimport { createClipPath } from '../helper/createClipPathFromCoordSys.js';\nimport Sausage from '../../util/shape/sausage.js';\nimport ChartView from '../../view/Chart.js';\nimport { isCoordinateSystemType } from '../../coord/CoordinateSystem.js';\nimport { getDefaultLabel, getDefaultInterpolatedLabel } from '../helper/labelHelper.js';\nimport { warn } from '../../util/log.js';\nimport { createSectorCalculateTextPosition, setSectorTextRotation } from '../../label/sectorLabel.js';\nimport { saveOldStyle } from '../../animation/basicTransition.js';\nimport { getSectorCornerRadius } from '../helper/sectorHelper.js';\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nfunction getClipArea(coord, data) {\n  var coordSysClipArea = coord.getArea && coord.getArea();\n  if (isCoordinateSystemType(coord, 'cartesian2d')) {\n    var baseAxis = coord.getBaseAxis();\n    // When boundaryGap is false or using time axis. bar may exceed the grid.\n    // We should not clip this part.\n    // See test/bar2.html\n    if (baseAxis.type !== 'category' || !baseAxis.onBand) {\n      var expandWidth = data.getLayout('bandWidth');\n      if (baseAxis.isHorizontal()) {\n        coordSysClipArea.x -= expandWidth;\n        coordSysClipArea.width += expandWidth * 2;\n      } else {\n        coordSysClipArea.y -= expandWidth;\n        coordSysClipArea.height += expandWidth * 2;\n      }\n    }\n  }\n  return coordSysClipArea;\n}\nvar BarView = /** @class */function (_super) {\n  __extends(BarView, _super);\n  function BarView() {\n    var _this = _super.call(this) || this;\n    _this.type = BarView.type;\n    _this._isFirstFrame = true;\n    return _this;\n  }\n  BarView.prototype.render = function (seriesModel, ecModel, api, payload) {\n    this._model = seriesModel;\n    this._removeOnRenderedListener(api);\n    this._updateDrawMode(seriesModel);\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      // Clear previously rendered progressive elements.\n      this._progressiveEls = null;\n      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn('Only cartesian2d and polar supported for bar.');\n    }\n  };\n  BarView.prototype.incrementalPrepareRender = function (seriesModel) {\n    this._clear();\n    this._updateDrawMode(seriesModel);\n    // incremental also need to clip, otherwise might be overlow.\n    // But must not set clip in each frame, otherwise all of the children will be marked redraw.\n    this._updateLargeClip(seriesModel);\n  };\n  BarView.prototype.incrementalRender = function (params, seriesModel) {\n    // Reset\n    this._progressiveEls = [];\n    // Do not support progressive in normal mode.\n    this._incrementalRenderLarge(params, seriesModel);\n  };\n  BarView.prototype.eachRendered = function (cb) {\n    traverseElements(this._progressiveEls || this.group, cb);\n  };\n  BarView.prototype._updateDrawMode = function (seriesModel) {\n    var isLargeDraw = seriesModel.pipelineContext.large;\n    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {\n      this._isLargeDraw = isLargeDraw;\n      this._clear();\n    }\n  };\n  BarView.prototype._renderNormal = function (seriesModel, ecModel, api, payload) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);\n    if (realtimeSortCfg) {\n      this._enableRealtimeSort(realtimeSortCfg, data, api);\n    }\n    var needsClip = seriesModel.get('clip', true) || realtimeSortCfg;\n    var coordSysClipArea = getClipArea(coord, data);\n    // If there is clipPath created in large mode. Remove it.\n    group.removeClipPath();\n    // We don't use clipPath in normal mode because we needs a perfect animation\n    // And don't want the label are clipped.\n    var roundCap = seriesModel.get('roundCap', true);\n    var drawBackground = seriesModel.get('showBackground', true);\n    var backgroundModel = seriesModel.getModel('backgroundStyle');\n    var barBorderRadius = backgroundModel.get('borderRadius') || 0;\n    var bgEls = [];\n    var oldBgEls = this._backgroundEls;\n    var isInitSort = payload && payload.isInitSort;\n    var isChangeOrder = payload && payload.type === 'changeAxisOrder';\n    function createBackground(dataIndex) {\n      var bgLayout = getLayout[coord.type](data, dataIndex);\n      if (!bgLayout) {\n        return null;\n      }\n      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);\n      bgEl.useStyle(backgroundModel.getItemStyle());\n      // Only cartesian2d support borderRadius.\n      if (coord.type === 'cartesian2d') {\n        bgEl.setShape('r', barBorderRadius);\n      } else {\n        bgEl.setShape('cornerRadius', barBorderRadius);\n      }\n      bgEls[dataIndex] = bgEl;\n      return bgEl;\n    }\n    ;\n    data.diff(oldData).add(function (dataIndex) {\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      if (!layout) {\n        return;\n      }\n      if (drawBackground) {\n        createBackground(dataIndex);\n      }\n      // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in \"axisProxy\".\n      if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout)) {\n        return;\n      }\n      var isClipped = false;\n      if (needsClip) {\n        // Clip will modify the layout params.\n        // And return a boolean to determine if the shape are fully clipped.\n        isClipped = clip[coord.type](coordSysClipArea, layout);\n      }\n      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);\n      if (realtimeSortCfg) {\n        /**\n         * Force label animation because even if the element is\n         * ignored because it's clipped, it may not be clipped after\n         * changing order. Then, if not using forceLabelAnimation,\n         * the label animation was never started, in which case,\n         * the label will be the final value and doesn't have label\n         * animation.\n         */\n        el.forceLabelAnimation = true;\n      }\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n      if (isInitSort) {\n        el.attr({\n          shape: layout\n        });\n      } else if (realtimeSortCfg) {\n        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, dataIndex, isHorizontalOrRadial, false, false);\n      } else {\n        initProps(el, {\n          shape: layout\n        }, seriesModel, dataIndex);\n      }\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      el.ignore = isClipped;\n    }).update(function (newIndex, oldIndex) {\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n      if (!layout) {\n        return;\n      }\n      if (drawBackground) {\n        var bgEl = void 0;\n        if (oldBgEls.length === 0) {\n          bgEl = createBackground(oldIndex);\n        } else {\n          bgEl = oldBgEls[oldIndex];\n          bgEl.useStyle(backgroundModel.getItemStyle());\n          // Only cartesian2d support borderRadius.\n          if (coord.type === 'cartesian2d') {\n            bgEl.setShape('r', barBorderRadius);\n          } else {\n            bgEl.setShape('cornerRadius', barBorderRadius);\n          }\n          bgEls[newIndex] = bgEl;\n        }\n        var bgLayout = getLayout[coord.type](data, newIndex);\n        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);\n        updateProps(bgEl, {\n          shape: shape\n        }, animationModel, newIndex);\n      }\n      var el = oldData.getItemGraphicEl(oldIndex);\n      if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout)) {\n        group.remove(el);\n        return;\n      }\n      var isClipped = false;\n      if (needsClip) {\n        isClipped = clip[coord.type](coordSysClipArea, layout);\n        if (isClipped) {\n          group.remove(el);\n        }\n      }\n      var roundCapChanged = el && (el.type === 'sector' && roundCap || el.type === 'sausage' && !roundCap);\n      if (roundCapChanged) {\n        // roundCap changed, there is no way to use animation from a `sector` to a `sausage` shape,\n        // so remove the old one and create a new shape\n        el && removeElementWithFadeOut(el, seriesModel, oldIndex);\n        el = null;\n      }\n      if (!el) {\n        el = elementCreator[coord.type](seriesModel, data, newIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, true, roundCap);\n      } else {\n        saveOldStyle(el);\n      }\n      if (realtimeSortCfg) {\n        el.forceLabelAnimation = true;\n      }\n      if (isChangeOrder) {\n        var textEl = el.getTextContent();\n        if (textEl) {\n          var labelInnerStore = labelInner(textEl);\n          if (labelInnerStore.prevValue != null) {\n            /**\n             * Set preValue to be value so that no new label\n             * should be started, otherwise, it will take a full\n             * `animationDurationUpdate` time to finish the\n             * animation, which is not expected.\n             */\n            labelInnerStore.prevValue = labelInnerStore.value;\n          }\n        }\n      }\n      // Not change anything if only order changed.\n      // Especially not change label.\n      else {\n        updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n      }\n      if (isInitSort) {\n        el.attr({\n          shape: layout\n        });\n      } else if (realtimeSortCfg) {\n        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, newIndex, isHorizontalOrRadial, true, isChangeOrder);\n      } else {\n        updateProps(el, {\n          shape: layout\n        }, seriesModel, newIndex, null);\n      }\n      data.setItemGraphicEl(newIndex, el);\n      el.ignore = isClipped;\n      group.add(el);\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n      el && removeElementWithFadeOut(el, seriesModel, dataIndex);\n    }).execute();\n    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group());\n    bgGroup.removeAll();\n    for (var i = 0; i < bgEls.length; ++i) {\n      bgGroup.add(bgEls[i]);\n    }\n    group.add(bgGroup);\n    this._backgroundEls = bgEls;\n    this._data = data;\n  };\n  BarView.prototype._renderLarge = function (seriesModel, ecModel, api) {\n    this._clear();\n    createLarge(seriesModel, this.group);\n    this._updateLargeClip(seriesModel);\n  };\n  BarView.prototype._incrementalRenderLarge = function (params, seriesModel) {\n    this._removeBackground();\n    createLarge(seriesModel, this.group, this._progressiveEls, true);\n  };\n  BarView.prototype._updateLargeClip = function (seriesModel) {\n    // Use clipPath in large mode.\n    var clipPath = seriesModel.get('clip', true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);\n    var group = this.group;\n    if (clipPath) {\n      group.setClipPath(clipPath);\n    } else {\n      group.removeClipPath();\n    }\n  };\n  BarView.prototype._enableRealtimeSort = function (realtimeSortCfg, data, api) {\n    var _this = this;\n    // If no data in the first frame, wait for data to initSort\n    if (!data.count()) {\n      return;\n    }\n    var baseAxis = realtimeSortCfg.baseAxis;\n    if (this._isFirstFrame) {\n      this._dispatchInitSort(data, realtimeSortCfg, api);\n      this._isFirstFrame = false;\n    } else {\n      var orderMapping_1 = function (idx) {\n        var el = data.getItemGraphicEl(idx);\n        var shape = el && el.shape;\n        return shape &&\n        // The result should be consistent with the initial sort by data value.\n        // Do not support the case that both positive and negative exist.\n        Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width)\n        // If data is NaN, shape.xxx may be NaN, so use || 0 here in case\n        || 0;\n      };\n      this._onRendered = function () {\n        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);\n      };\n      api.getZr().on('rendered', this._onRendered);\n    }\n  };\n  BarView.prototype._dataSort = function (data, baseAxis, orderMapping) {\n    var info = [];\n    data.each(data.mapDimension(baseAxis.dim), function (ordinalNumber, dataIdx) {\n      var mappedValue = orderMapping(dataIdx);\n      mappedValue = mappedValue == null ? NaN : mappedValue;\n      info.push({\n        dataIndex: dataIdx,\n        mappedValue: mappedValue,\n        ordinalNumber: ordinalNumber\n      });\n    });\n    info.sort(function (a, b) {\n      // If NaN, it will be treated as min val.\n      return b.mappedValue - a.mappedValue;\n    });\n    return {\n      ordinalNumbers: map(info, function (item) {\n        return item.ordinalNumber;\n      })\n    };\n  };\n  BarView.prototype._isOrderChangedWithinSameData = function (data, orderMapping, baseAxis) {\n    var scale = baseAxis.scale;\n    var ordinalDataDim = data.mapDimension(baseAxis.dim);\n    var lastValue = Number.MAX_VALUE;\n    for (var tickNum = 0, len = scale.getOrdinalMeta().categories.length; tickNum < len; ++tickNum) {\n      var rawIdx = data.rawIndexOf(ordinalDataDim, scale.getRawOrdinalNumber(tickNum));\n      var value = rawIdx < 0\n      // If some tick have no bar, the tick will be treated as min.\n      ? Number.MIN_VALUE\n      // PENDING: if dataZoom on baseAxis exits, is it a performance issue?\n      : orderMapping(data.indexOfRawIndex(rawIdx));\n      if (value > lastValue) {\n        return true;\n      }\n      lastValue = value;\n    }\n    return false;\n  };\n  /*\n   * Consider the case when A and B changed order, whose representing\n   * bars are both out of sight, we don't wish to trigger reorder action\n   * as long as the order in the view doesn't change.\n   */\n  BarView.prototype._isOrderDifferentInView = function (orderInfo, baseAxis) {\n    var scale = baseAxis.scale;\n    var extent = scale.getExtent();\n    var tickNum = Math.max(0, extent[0]);\n    var tickMax = Math.min(extent[1], scale.getOrdinalMeta().categories.length - 1);\n    for (; tickNum <= tickMax; ++tickNum) {\n      if (orderInfo.ordinalNumbers[tickNum] !== scale.getRawOrdinalNumber(tickNum)) {\n        return true;\n      }\n    }\n  };\n  BarView.prototype._updateSortWithinSameData = function (data, orderMapping, baseAxis, api) {\n    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {\n      return;\n    }\n    var sortInfo = this._dataSort(data, baseAxis, orderMapping);\n    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {\n      this._removeOnRenderedListener(api);\n      api.dispatchAction({\n        type: 'changeAxisOrder',\n        componentType: baseAxis.dim + 'Axis',\n        axisId: baseAxis.index,\n        sortInfo: sortInfo\n      });\n    }\n  };\n  BarView.prototype._dispatchInitSort = function (data, realtimeSortCfg, api) {\n    var baseAxis = realtimeSortCfg.baseAxis;\n    var sortResult = this._dataSort(data, baseAxis, function (dataIdx) {\n      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);\n    });\n    api.dispatchAction({\n      type: 'changeAxisOrder',\n      componentType: baseAxis.dim + 'Axis',\n      isInitSort: true,\n      axisId: baseAxis.index,\n      sortInfo: sortResult\n    });\n  };\n  BarView.prototype.remove = function (ecModel, api) {\n    this._clear(this._model);\n    this._removeOnRenderedListener(api);\n  };\n  BarView.prototype.dispose = function (ecModel, api) {\n    this._removeOnRenderedListener(api);\n  };\n  BarView.prototype._removeOnRenderedListener = function (api) {\n    if (this._onRendered) {\n      api.getZr().off('rendered', this._onRendered);\n      this._onRendered = null;\n    }\n  };\n  BarView.prototype._clear = function (model) {\n    var group = this.group;\n    var data = this._data;\n    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {\n      this._removeBackground();\n      this._backgroundEls = [];\n      data.eachItemGraphicEl(function (el) {\n        removeElementWithFadeOut(el, model, getECData(el).dataIndex);\n      });\n    } else {\n      group.removeAll();\n    }\n    this._data = null;\n    this._isFirstFrame = true;\n  };\n  BarView.prototype._removeBackground = function () {\n    this.group.remove(this._backgroundGroup);\n    this._backgroundGroup = null;\n  };\n  BarView.type = 'bar';\n  return BarView;\n}(ChartView);\nvar clip = {\n  cartesian2d: function (coordSysBoundingRect, layout) {\n    var signWidth = layout.width < 0 ? -1 : 1;\n    var signHeight = layout.height < 0 ? -1 : 1;\n    // Needs positive width and height\n    if (signWidth < 0) {\n      layout.x += layout.width;\n      layout.width = -layout.width;\n    }\n    if (signHeight < 0) {\n      layout.y += layout.height;\n      layout.height = -layout.height;\n    }\n    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;\n    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;\n    var x = mathMax(layout.x, coordSysBoundingRect.x);\n    var x2 = mathMin(layout.x + layout.width, coordSysX2);\n    var y = mathMax(layout.y, coordSysBoundingRect.y);\n    var y2 = mathMin(layout.y + layout.height, coordSysY2);\n    var xClipped = x2 < x;\n    var yClipped = y2 < y;\n    // When xClipped or yClipped, the element will be marked as `ignore`.\n    // But we should also place the element at the edge of the coord sys bounding rect.\n    // Because if data changed and the bar shows again, its transition animation\n    // will begin at this place.\n    layout.x = xClipped && x > coordSysX2 ? x2 : x;\n    layout.y = yClipped && y > coordSysY2 ? y2 : y;\n    layout.width = xClipped ? 0 : x2 - x;\n    layout.height = yClipped ? 0 : y2 - y;\n    // Reverse back\n    if (signWidth < 0) {\n      layout.x += layout.width;\n      layout.width = -layout.width;\n    }\n    if (signHeight < 0) {\n      layout.y += layout.height;\n      layout.height = -layout.height;\n    }\n    return xClipped || yClipped;\n  },\n  polar: function (coordSysClipArea, layout) {\n    var signR = layout.r0 <= layout.r ? 1 : -1;\n    // Make sure r is larger than r0\n    if (signR < 0) {\n      var tmp = layout.r;\n      layout.r = layout.r0;\n      layout.r0 = tmp;\n    }\n    var r = mathMin(layout.r, coordSysClipArea.r);\n    var r0 = mathMax(layout.r0, coordSysClipArea.r0);\n    layout.r = r;\n    layout.r0 = r0;\n    var clipped = r - r0 < 0;\n    // Reverse back\n    if (signR < 0) {\n      var tmp = layout.r;\n      layout.r = layout.r0;\n      layout.r0 = tmp;\n    }\n    return clipped;\n  }\n};\nvar elementCreator = {\n  cartesian2d: function (seriesModel, data, newIndex, layout, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {\n    var rect = new Rect({\n      shape: extend({}, layout),\n      z2: 1\n    });\n    rect.__dataIndex = newIndex;\n    rect.name = 'item';\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      rectShape[animateProperty] = 0;\n    }\n    return rect;\n  },\n  polar: function (seriesModel, data, newIndex, layout, isRadial, animationModel, axisModel, isUpdate, roundCap) {\n    var ShapeClass = !isRadial && roundCap ? Sausage : Sector;\n    var sector = new ShapeClass({\n      shape: layout,\n      z2: 1\n    });\n    sector.name = 'item';\n    var positionMap = createPolarPositionMapping(isRadial);\n    sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {\n      isRoundCap: ShapeClass === Sausage\n    });\n    // Animation\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? layout.r0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      (isUpdate ? updateProps : initProps)(sector, {\n        shape: animateTarget\n        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue\n      }, animationModel);\n    }\n    return sector;\n  }\n};\nfunction shouldRealtimeSort(seriesModel, coordSys) {\n  var realtimeSortOption = seriesModel.get('realtimeSort', true);\n  var baseAxis = coordSys.getBaseAxis();\n  if (process.env.NODE_ENV !== 'production') {\n    if (realtimeSortOption) {\n      if (baseAxis.type !== 'category') {\n        warn('`realtimeSort` will not work because this bar series is not based on a category axis.');\n      }\n      if (coordSys.type !== 'cartesian2d') {\n        warn('`realtimeSort` will not work because this bar series is not on cartesian2d.');\n      }\n    }\n  }\n  if (realtimeSortOption && baseAxis.type === 'category' && coordSys.type === 'cartesian2d') {\n    return {\n      baseAxis: baseAxis,\n      otherAxis: coordSys.getOtherAxis(baseAxis)\n    };\n  }\n}\nfunction updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout, newIndex, isHorizontal, isUpdate, isChangeOrder) {\n  var seriesTarget;\n  var axisTarget;\n  if (isHorizontal) {\n    axisTarget = {\n      x: layout.x,\n      width: layout.width\n    };\n    seriesTarget = {\n      y: layout.y,\n      height: layout.height\n    };\n  } else {\n    axisTarget = {\n      y: layout.y,\n      height: layout.height\n    };\n    seriesTarget = {\n      x: layout.x,\n      width: layout.width\n    };\n  }\n  if (!isChangeOrder) {\n    // Keep the original growth animation if only axis order changed.\n    // Not start a new animation.\n    (isUpdate ? updateProps : initProps)(el, {\n      shape: seriesTarget\n    }, seriesAnimationModel, newIndex, null);\n  }\n  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;\n  (isUpdate ? updateProps : initProps)(el, {\n    shape: axisTarget\n  }, axisAnimationModel, newIndex);\n}\nfunction checkPropertiesNotValid(obj, props) {\n  for (var i = 0; i < props.length; i++) {\n    if (!isFinite(obj[props[i]])) {\n      return true;\n    }\n  }\n  return false;\n}\nvar rectPropties = ['x', 'y', 'width', 'height'];\nvar polarPropties = ['cx', 'cy', 'r', 'startAngle', 'endAngle'];\nvar isValidLayout = {\n  cartesian2d: function (layout) {\n    return !checkPropertiesNotValid(layout, rectPropties);\n  },\n  polar: function (layout) {\n    return !checkPropertiesNotValid(layout, polarPropties);\n  }\n};\nvar getLayout = {\n  // itemModel is only used to get borderWidth, which is not needed\n  // when calculating bar background layout.\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    if (!layout) {\n      return null;\n    }\n    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0;\n    // fix layout with lineWidth\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle,\n      clockwise: layout.clockwise\n    };\n  }\n};\nfunction isZeroOnPolar(layout) {\n  return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;\n}\nfunction createPolarPositionMapping(isRadial) {\n  return function (isRadial) {\n    var arcOrAngle = isRadial ? 'Arc' : 'Angle';\n    return function (position) {\n      switch (position) {\n        case 'start':\n        case 'insideStart':\n        case 'end':\n        case 'insideEnd':\n          return position + arcOrAngle;\n        default:\n          return position;\n      }\n    };\n  }(isRadial);\n}\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, isPolar) {\n  var style = data.getItemVisual(dataIndex, 'style');\n  if (!isPolar) {\n    var borderRadius = itemModel.get(['itemStyle', 'borderRadius']) || 0;\n    el.setShape('r', borderRadius);\n  } else if (!seriesModel.get('roundCap')) {\n    var sectorShape = el.shape;\n    var cornerRadius = getSectorCornerRadius(itemModel.getModel('itemStyle'), sectorShape, true);\n    extend(sectorShape, cornerRadius);\n    el.setShape(sectorShape);\n  }\n  el.useStyle(style);\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout.r >= layout.r0 ? 'endArc' : 'startArc' : layout.endAngle >= layout.startAngle ? 'endAngle' : 'startAngle' : isHorizontalOrRadial ? layout.height >= 0 ? 'bottom' : 'top' : layout.width >= 0 ? 'right' : 'left';\n  var labelStatesModels = getLabelStatesModels(itemModel);\n  setLabelStyle(el, labelStatesModels, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),\n    inheritColor: style.fill,\n    defaultOpacity: style.opacity,\n    defaultOutsidePosition: labelPositionOutside\n  });\n  var label = el.getTextContent();\n  if (isPolar && label) {\n    var position = itemModel.get(['label', 'position']);\n    el.textConfig.inside = position === 'middle' ? true : null;\n    setSectorTextRotation(el, position === 'outside' ? labelPositionOutside : position, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(['label', 'rotate']));\n  }\n  setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function (value) {\n    return getDefaultInterpolatedLabel(data, value);\n  });\n  var emphasisModel = itemModel.getModel(['emphasis']);\n  toggleHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n  setStatesStylesFromModel(el, itemModel);\n  if (isZeroOnPolar(layout)) {\n    el.style.fill = 'none';\n    el.style.stroke = 'none';\n    each(el.states, function (state) {\n      if (state.style) {\n        state.style.fill = state.style.stroke = 'none';\n      }\n    });\n  }\n}\n// In case width or height are too small.\nfunction getLineWidth(itemModel, rawLayout) {\n  // Has no border.\n  var borderColor = itemModel.get(['itemStyle', 'borderColor']);\n  if (!borderColor || borderColor === 'none') {\n    return 0;\n  }\n  var lineWidth = itemModel.get(['itemStyle', 'borderWidth']) || 0;\n  // width or height may be NaN for empty data\n  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);\n  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);\n  return Math.min(lineWidth, width, height);\n}\nvar LagePathShape = /** @class */function () {\n  function LagePathShape() {}\n  return LagePathShape;\n}();\nvar LargePath = /** @class */function (_super) {\n  __extends(LargePath, _super);\n  function LargePath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'largeBar';\n    return _this;\n  }\n  LargePath.prototype.getDefaultShape = function () {\n    return new LagePathShape();\n  };\n  LargePath.prototype.buildPath = function (ctx, shape) {\n    // Drawing lines is more efficient than drawing\n    // a whole line or drawing rects.\n    var points = shape.points;\n    var baseDimIdx = this.baseDimIdx;\n    var valueDimIdx = 1 - this.baseDimIdx;\n    var startPoint = [];\n    var size = [];\n    var barWidth = this.barWidth;\n    for (var i = 0; i < points.length; i += 3) {\n      size[baseDimIdx] = barWidth;\n      size[valueDimIdx] = points[i + 2];\n      startPoint[baseDimIdx] = points[i + baseDimIdx];\n      startPoint[valueDimIdx] = points[i + valueDimIdx];\n      ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);\n    }\n  };\n  return LargePath;\n}(Path);\nfunction createLarge(seriesModel, group, progressiveEls, incremental) {\n  // TODO support polar\n  var data = seriesModel.getData();\n  var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;\n  var largeDataIndices = data.getLayout('largeDataIndices');\n  var barWidth = data.getLayout('size');\n  var backgroundModel = seriesModel.getModel('backgroundStyle');\n  var bgPoints = data.getLayout('largeBackgroundPoints');\n  if (bgPoints) {\n    var bgEl = new LargePath({\n      shape: {\n        points: bgPoints\n      },\n      incremental: !!incremental,\n      silent: true,\n      z2: 0\n    });\n    bgEl.baseDimIdx = baseDimIdx;\n    bgEl.largeDataIndices = largeDataIndices;\n    bgEl.barWidth = barWidth;\n    bgEl.useStyle(backgroundModel.getItemStyle());\n    group.add(bgEl);\n    progressiveEls && progressiveEls.push(bgEl);\n  }\n  var el = new LargePath({\n    shape: {\n      points: data.getLayout('largePoints')\n    },\n    incremental: !!incremental,\n    ignoreCoarsePointer: true,\n    z2: 1\n  });\n  el.baseDimIdx = baseDimIdx;\n  el.largeDataIndices = largeDataIndices;\n  el.barWidth = barWidth;\n  group.add(el);\n  el.useStyle(data.getVisual('style'));\n  // Stroke is rendered first to avoid overlapping with fill\n  el.style.stroke = null;\n  // Enable tooltip and user mouse/touch event handlers.\n  getECData(el).seriesIndex = seriesModel.seriesIndex;\n  if (!seriesModel.get('silent')) {\n    el.on('mousedown', largePathUpdateDataIndex);\n    el.on('mousemove', largePathUpdateDataIndex);\n  }\n  progressiveEls && progressiveEls.push(el);\n}\n// Use throttle to avoid frequently traverse to find dataIndex.\nvar largePathUpdateDataIndex = throttle(function (event) {\n  var largePath = this;\n  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);\n  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;\n}, 30, false);\nfunction largePathFindDataIndex(largePath, x, y) {\n  var baseDimIdx = largePath.baseDimIdx;\n  var valueDimIdx = 1 - baseDimIdx;\n  var points = largePath.shape.points;\n  var largeDataIndices = largePath.largeDataIndices;\n  var startPoint = [];\n  var size = [];\n  var barWidth = largePath.barWidth;\n  for (var i = 0, len = points.length / 3; i < len; i++) {\n    var ii = i * 3;\n    size[baseDimIdx] = barWidth;\n    size[valueDimIdx] = points[ii + 2];\n    startPoint[baseDimIdx] = points[ii + baseDimIdx];\n    startPoint[valueDimIdx] = points[ii + valueDimIdx];\n    if (size[valueDimIdx] < 0) {\n      startPoint[valueDimIdx] += size[valueDimIdx];\n      size[valueDimIdx] = -size[valueDimIdx];\n    }\n    if (x >= startPoint[0] && x <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) {\n      return largeDataIndices[i];\n    }\n  }\n  return -1;\n}\nfunction createBackgroundShape(isHorizontalOrRadial, layout, coord) {\n  if (isCoordinateSystemType(coord, 'cartesian2d')) {\n    var rectShape = layout;\n    var coordLayout = coord.getArea();\n    return {\n      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,\n      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,\n      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,\n      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height\n    };\n  } else {\n    var coordLayout = coord.getArea();\n    var sectorShape = layout;\n    return {\n      cx: coordLayout.cx,\n      cy: coordLayout.cy,\n      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,\n      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,\n      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,\n      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2\n    };\n  }\n}\nfunction createBackgroundEl(coord, isHorizontalOrRadial, layout) {\n  var ElementClz = coord.type === 'polar' ? Sector : Rect;\n  return new ElementClz({\n    shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),\n    silent: true,\n    z2: 0\n  });\n}\nexport default BarView;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}